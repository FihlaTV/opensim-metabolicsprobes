<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenSim: OpenSim::Property&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenSim
   &#160;<span id="projectnumber">OpenSim 3.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classOpenSim_1_1Property.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classOpenSim_1_1Property-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenSim::Property&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T.  
 <a href="classOpenSim_1_1Property.html#details">More...</a></p>

<p><code>#include &lt;Property.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OpenSim::Property&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOpenSim_1_1Property.png" usemap="#OpenSim::Property&lt; T &gt;_map" alt=""/>
  <map id="OpenSim::Property&lt; T &gt;_map" name="OpenSim::Property&lt; T &gt;_map">
<area href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va..." alt="OpenSim::AbstractProperty" shape="rect" coords="0,0,165,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenSim_1_1Property_1_1TypeHelper.html">TypeHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the generic definition of <a class="el" href="structOpenSim_1_1Property_1_1TypeHelper.html" title="This is the generic definition of Property::TypeHelper to be used whenever T does not have a speciali...">Property::TypeHelper</a> to be used whenever T does not have a specialization, meaning that T must be a type derived from class <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.  <a href="structOpenSim_1_1Property_1_1TypeHelper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeeca88c50f8115970c150889b1fd1ab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Property.html">Property</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#aeeca88c50f8115970c150889b1fd1ab3">clone</a> () const override=0</td></tr>
<tr class="memdesc:aeeca88c50f8115970c150889b1fd1ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new, deep copy (clone) of this concrete property and return a pointer to the heap space.  <a href="#aeeca88c50f8115970c150889b1fd1ab3"></a><br/></td></tr>
<tr class="separator:aeeca88c50f8115970c150889b1fd1ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97bf9a52c4547bc78c6efeed7496d20"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#af97bf9a52c4547bc78c6efeed7496d20">getTypeName</a> () const final</td></tr>
<tr class="memdesc:af97bf9a52c4547bc78c6efeed7496d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="structOpenSim_1_1Property_1_1TypeHelper.html" title="This is the generic definition of Property::TypeHelper to be used whenever T does not have a speciali...">TypeHelper</a>'s <a class="el" href="classOpenSim_1_1Property.html#af97bf9a52c4547bc78c6efeed7496d20" title="Use TypeHelper&#39;s getTypeName() to satisfy this pure virtual.">getTypeName()</a> to satisfy this pure virtual.  <a href="#af97bf9a52c4547bc78c6efeed7496d20"></a><br/></td></tr>
<tr class="separator:af97bf9a52c4547bc78c6efeed7496d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e132b9552b6c2a9cc8f6a33576fcb1a"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a7e132b9552b6c2a9cc8f6a33576fcb1a">operator[]</a> (int i) const </td></tr>
<tr class="memdesc:a7e132b9552b6c2a9cc8f6a33576fcb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to one of the values in the value list.  <a href="#a7e132b9552b6c2a9cc8f6a33576fcb1a"></a><br/></td></tr>
<tr class="separator:a7e132b9552b6c2a9cc8f6a33576fcb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567d26efb726367aca90f2534b032352"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a567d26efb726367aca90f2534b032352">operator[]</a> (int i)</td></tr>
<tr class="memdesc:a567d26efb726367aca90f2534b032352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a writable reference to one of the values in the value list.  <a href="#a567d26efb726367aca90f2534b032352"></a><br/></td></tr>
<tr class="separator:a567d26efb726367aca90f2534b032352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c23999672ed5ec0d74d140a67e89ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#aa9c23999672ed5ec0d74d140a67e89ea">operator=</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aa9c23999672ed5ec0d74d140a67e89ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a value of type T sets the value of this single-valued property to a copy of the supplied <em>value</em>; not allowed for a list property.  <a href="#aa9c23999672ed5ec0d74d140a67e89ea"></a><br/></td></tr>
<tr class="separator:aa9c23999672ed5ec0d74d140a67e89ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Container&gt; </td></tr>
<tr class="memitem:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#af3f1f6ba165cb5bd24cab98a22a8076c">operator=</a> (const Container&lt; T &gt; &amp;valueList)</td></tr>
<tr class="memdesc:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container.  <a href="#af3f1f6ba165cb5bd24cab98a22a8076c"></a><br/></td></tr>
<tr class="separator:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8b68f9fa4cf67c5b9d681b4499d63e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a3a8b68f9fa4cf67c5b9d681b4499d63e">setValue</a> (int i, const T &amp;value)</td></tr>
<tr class="memdesc:a3a8b68f9fa4cf67c5b9d681b4499d63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the i'th value list element with a copy of the given <em>value</em>.  <a href="#a3a8b68f9fa4cf67c5b9d681b4499d63e"></a><br/></td></tr>
<tr class="separator:a3a8b68f9fa4cf67c5b9d681b4499d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92e55af5a211a210900438d858a481a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#aa92e55af5a211a210900438d858a481a">setValue</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aa92e55af5a211a210900438d858a481a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a new value for a single-valued property.  <a href="#aa92e55af5a211a210900438d858a481a"></a><br/></td></tr>
<tr class="separator:aa92e55af5a211a210900438d858a481a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00355490194329012905b3407917fe9e"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Container&gt; </td></tr>
<tr class="memitem:a00355490194329012905b3407917fe9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a00355490194329012905b3407917fe9e">setValue</a> (const Container&lt; T &gt; &amp;valueList)</td></tr>
<tr class="memdesc:a00355490194329012905b3407917fe9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container.  <a href="#a00355490194329012905b3407917fe9e"></a><br/></td></tr>
<tr class="separator:a00355490194329012905b3407917fe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e1ead8242e6c28a48c1a99b849ecfb"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a66e1ead8242e6c28a48c1a99b849ecfb">getValue</a> (int index=-1) const </td></tr>
<tr class="memdesc:a66e1ead8242e6c28a48c1a99b849ecfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the selected value from this property's value list.  <a href="#a66e1ead8242e6c28a48c1a99b849ecfb"></a><br/></td></tr>
<tr class="separator:a66e1ead8242e6c28a48c1a99b849ecfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae597340fa1da9385439bbebf91a6a92a"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ae597340fa1da9385439bbebf91a6a92a">updValue</a> (int index=-1)</td></tr>
<tr class="memdesc:ae597340fa1da9385439bbebf91a6a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the selected value from this property's value list.  <a href="#ae597340fa1da9385439bbebf91a6a92a"></a><br/></td></tr>
<tr class="separator:ae597340fa1da9385439bbebf91a6a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cebe3dfc74cb4f1d5158a4feb449e05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a8cebe3dfc74cb4f1d5158a4feb449e05">appendValue</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a8cebe3dfc74cb4f1d5158a4feb449e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a copy of the supplied <em>value</em> to the end of this property's value list.  <a href="#a8cebe3dfc74cb4f1d5158a4feb449e05"></a><br/></td></tr>
<tr class="separator:a8cebe3dfc74cb4f1d5158a4feb449e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8d2992c9f493380aa3400a6f6ec9a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a7f8d2992c9f493380aa3400a6f6ec9a8">appendValue</a> (const T *value)</td></tr>
<tr class="memdesc:a7f8d2992c9f493380aa3400a6f6ec9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a <em>copy</em> of the supplied <em>value</em> to the end of this property's value list.  <a href="#a7f8d2992c9f493380aa3400a6f6ec9a8"></a><br/></td></tr>
<tr class="separator:a7f8d2992c9f493380aa3400a6f6ec9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f955ce364fd5c6a031263894a77c6a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a7f955ce364fd5c6a031263894a77c6a2">adoptAndAppendValue</a> (T *value)</td></tr>
<tr class="memdesc:a7f955ce364fd5c6a031263894a77c6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new value to the end of this property's value list, taking over ownership of the supplied heap-allocated object.  <a href="#a7f955ce364fd5c6a031263894a77c6a2"></a><br/></td></tr>
<tr class="separator:a7f955ce364fd5c6a031263894a77c6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9169673da96ab5c0da51048ef331f134"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a9169673da96ab5c0da51048ef331f134">findIndex</a> (const T &amp;value) const </td></tr>
<tr class="memdesc:a9169673da96ab5c0da51048ef331f134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the value list for an element that has the given <em>value</em> and return its index if found, otherwise -1.  <a href="#a9169673da96ab5c0da51048ef331f134"></a><br/></td></tr>
<tr class="separator:a9169673da96ab5c0da51048ef331f134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classOpenSim_1_1AbstractProperty"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classOpenSim_1_1AbstractProperty')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classOpenSim_1_1AbstractProperty.html">OpenSim::AbstractProperty</a></td></tr>
<tr class="memitem:a0685f52599efbdd68462babddd4859e4 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a0685f52599efbdd68462babddd4859e4">setAllowableListSize</a> (int aMin, int aMax)</td></tr>
<tr class="memdesc:a0685f52599efbdd68462babddd4859e4 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require that the number of values n in the value list of this property be in the range aMin &lt;= n &lt;= aMax.  <a href="#a0685f52599efbdd68462babddd4859e4"></a><br/></td></tr>
<tr class="separator:a0685f52599efbdd68462babddd4859e4 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c9f2020339f49a08a9a3a3a37adc5f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a26c9f2020339f49a08a9a3a3a37adc5f">setAllowableListSize</a> (int aNum)</td></tr>
<tr class="memdesc:a26c9f2020339f49a08a9a3a3a37adc5f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require that the number of values n in the value list of this property be exactly n=aNum values.  <a href="#a26c9f2020339f49a08a9a3a3a37adc5f"></a><br/></td></tr>
<tr class="separator:a26c9f2020339f49a08a9a3a3a37adc5f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab21326774230e4921d6e912bbb1bb71 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#aab21326774230e4921d6e912bbb1bb71">~AbstractProperty</a> ()</td></tr>
<tr class="memdesc:aab21326774230e4921d6e912bbb1bb71 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all heap space used by this property.  <a href="#aab21326774230e4921d6e912bbb1bb71"></a><br/></td></tr>
<tr class="separator:aab21326774230e4921d6e912bbb1bb71 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385fae988f5d035ef20ad80f61c65cc7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a385fae988f5d035ef20ad80f61c65cc7">toString</a> () const =0</td></tr>
<tr class="memdesc:a385fae988f5d035ef20ad80f61c65cc7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">For relatively simple types, return the current value of this property in a string suitable for displaying to a user in the GUI.  <a href="#a385fae988f5d035ef20ad80f61c65cc7"></a><br/></td></tr>
<tr class="separator:a385fae988f5d035ef20ad80f61c65cc7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2478982e93cc5ad89e447b03e4aa48a5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a2478982e93cc5ad89e447b03e4aa48a5">isObjectProperty</a> () const =0</td></tr>
<tr class="memdesc:a2478982e93cc5ad89e447b03e4aa48a5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an "object property", meaning that its values are all concrete objects of types that ultimately derive from the OpenSim serializable base class <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.  <a href="#a2478982e93cc5ad89e447b03e4aa48a5"></a><br/></td></tr>
<tr class="separator:a2478982e93cc5ad89e447b03e4aa48a5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12b01d2c439e87470bd230c1061fab8 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ad12b01d2c439e87470bd230c1061fab8">isUnnamedProperty</a> () const =0</td></tr>
<tr class="memdesc:ad12b01d2c439e87470bd230c1061fab8 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unnamed property is a one-object property whose name was given as null or as the contained object's type tag.  <a href="#ad12b01d2c439e87470bd230c1061fab8"></a><br/></td></tr>
<tr class="separator:ad12b01d2c439e87470bd230c1061fab8 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a801d683ef4f717be82244c1b59678d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a5a801d683ef4f717be82244c1b59678d">equals</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;other) const </td></tr>
<tr class="memdesc:a5a801d683ef4f717be82244c1b59678d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this property with another one; this is primarily used for testing.  <a href="#a5a801d683ef4f717be82244c1b59678d"></a><br/></td></tr>
<tr class="separator:a5a801d683ef4f717be82244c1b59678d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2104fc45e1859ec3bf1d60982d2fdc36 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a2104fc45e1859ec3bf1d60982d2fdc36">isSamePropertyClass</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;other) const </td></tr>
<tr class="memdesc:a2104fc45e1859ec3bf1d60982d2fdc36 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the <em>other</em> property is an object of exactly the same concrete class as this one.  <a href="#a2104fc45e1859ec3bf1d60982d2fdc36"></a><br/></td></tr>
<tr class="separator:a2104fc45e1859ec3bf1d60982d2fdc36 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47afa59d32288a346e4461ab0ae70b28 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a47afa59d32288a346e4461ab0ae70b28">operator==</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;other) const </td></tr>
<tr class="memdesc:a47afa59d32288a346e4461ab0ae70b28 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5a801d683ef4f717be82244c1b59678d" title="Compare this property with another one; this is primarily used for testing.">equals()</a> method for the meaning of this operator.  <a href="#a47afa59d32288a346e4461ab0ae70b28"></a><br/></td></tr>
<tr class="separator:a47afa59d32288a346e4461ab0ae70b28 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47ef97b89f66793a42c7712275938b5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ab47ef97b89f66793a42c7712275938b5">setAllPropertiesUseDefault</a> (bool shouldUseDefault)</td></tr>
<tr class="memdesc:ab47ef97b89f66793a42c7712275938b5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the "use default" flag for this property and the properties of any objects it contains to the given value.  <a href="#ab47ef97b89f66793a42c7712275938b5"></a><br/></td></tr>
<tr class="separator:ab47ef97b89f66793a42c7712275938b5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f988432f0ac82f5e4c787879c16b3e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ae2f988432f0ac82f5e4c787879c16b3e">readFromXMLParentElement</a> (SimTK::Xml::Element &amp;parent, int versionNumber)</td></tr>
<tr class="memdesc:ae2f988432f0ac82f5e4c787879c16b3e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an XML parent element expected to contain a value for this property as an immediate child element, find that property element and set the property value from it.  <a href="#ae2f988432f0ac82f5e4c787879c16b3e"></a><br/></td></tr>
<tr class="separator:ae2f988432f0ac82f5e4c787879c16b3e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849306255cafd5f220c897131146a7a1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a849306255cafd5f220c897131146a7a1">writeToXMLParentElement</a> (SimTK::Xml::Element &amp;parent)</td></tr>
<tr class="memdesc:a849306255cafd5f220c897131146a7a1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an XML parent element, append a single child element representing the serialized form of this property.  <a href="#a849306255cafd5f220c897131146a7a1"></a><br/></td></tr>
<tr class="separator:a849306255cafd5f220c897131146a7a1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29bdc3ab4adbbfe954aed4a0780bee7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#af29bdc3ab4adbbfe954aed4a0780bee7">setName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:af29bdc3ab4adbbfe954aed4a0780bee7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property name.  <a href="#af29bdc3ab4adbbfe954aed4a0780bee7"></a><br/></td></tr>
<tr class="separator:af29bdc3ab4adbbfe954aed4a0780bee7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1cfb86a10115441ef84be3148c0c7d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#aac1cfb86a10115441ef84be3148c0c7d">setComment</a> (const std::string &amp;aComment)</td></tr>
<tr class="memdesc:aac1cfb86a10115441ef84be3148c0c7d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a user-friendly comment to be associated with property.  <a href="#aac1cfb86a10115441ef84be3148c0c7d"></a><br/></td></tr>
<tr class="separator:aac1cfb86a10115441ef84be3148c0c7d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ec6fb0a5d6beaef87cf228b34d48cf inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">setValueIsDefault</a> (bool isDefault)</td></tr>
<tr class="memdesc:a10ec6fb0a5d6beaef87cf228b34d48cf inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flag indicating whether the value of this property was simply taken from a default object and thus should not be written out when serializing.  <a href="#a10ec6fb0a5d6beaef87cf228b34d48cf"></a><br/></td></tr>
<tr class="separator:a10ec6fb0a5d6beaef87cf228b34d48cf inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd68b4e2e7ca1de8236f16ce71cda29 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a5bd68b4e2e7ca1de8236f16ce71cda29">getName</a> () const </td></tr>
<tr class="memdesc:a5bd68b4e2e7ca1de8236f16ce71cda29 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the property name.  <a href="#a5bd68b4e2e7ca1de8236f16ce71cda29"></a><br/></td></tr>
<tr class="separator:a5bd68b4e2e7ca1de8236f16ce71cda29 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd0ffc207e76a1a19b70c1e28e7291c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#afcd0ffc207e76a1a19b70c1e28e7291c">getComment</a> () const </td></tr>
<tr class="memdesc:afcd0ffc207e76a1a19b70c1e28e7291c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the comment associated with this property.  <a href="#afcd0ffc207e76a1a19b70c1e28e7291c"></a><br/></td></tr>
<tr class="separator:afcd0ffc207e76a1a19b70c1e28e7291c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9332e809f48f55f892eb99064c5b53 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#adb9332e809f48f55f892eb99064c5b53">getValueIsDefault</a> () const </td></tr>
<tr class="memdesc:adb9332e809f48f55f892eb99064c5b53 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flag indicating whether the current value is just the default value for this property (in which case it doesn't need to be written out).  <a href="#adb9332e809f48f55f892eb99064c5b53"></a><br/></td></tr>
<tr class="separator:adb9332e809f48f55f892eb99064c5b53 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d92ed0f4c96fe7810276c5393dfd65 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a08d92ed0f4c96fe7810276c5393dfd65">getMinListSize</a> () const </td></tr>
<tr class="memdesc:a08d92ed0f4c96fe7810276c5393dfd65 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum number of values allowed in this property's value list.  <a href="#a08d92ed0f4c96fe7810276c5393dfd65"></a><br/></td></tr>
<tr class="separator:a08d92ed0f4c96fe7810276c5393dfd65 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7ad40bcb2da56c7c7ac6df61127a66 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a6d7ad40bcb2da56c7c7ac6df61127a66">getMaxListSize</a> () const </td></tr>
<tr class="memdesc:a6d7ad40bcb2da56c7c7ac6df61127a66 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of values allowed in this property's value list.  <a href="#a6d7ad40bcb2da56c7c7ac6df61127a66"></a><br/></td></tr>
<tr class="separator:a6d7ad40bcb2da56c7c7ac6df61127a66 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ee42a879679c03a8a69f99998f2386 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a97ee42a879679c03a8a69f99998f2386">isOptionalProperty</a> () const </td></tr>
<tr class="memdesc:a97ee42a879679c03a8a69f99998f2386 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an "optional" property if its value list can contain at most one value.  <a href="#a97ee42a879679c03a8a69f99998f2386"></a><br/></td></tr>
<tr class="separator:a97ee42a879679c03a8a69f99998f2386 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2da76dbb28b3bd2d56dcbdbaf4aa5e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ada2da76dbb28b3bd2d56dcbdbaf4aa5e">isListProperty</a> () const </td></tr>
<tr class="memdesc:ada2da76dbb28b3bd2d56dcbdbaf4aa5e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "list" property if its value list can contain more than one value.  <a href="#ada2da76dbb28b3bd2d56dcbdbaf4aa5e"></a><br/></td></tr>
<tr class="separator:ada2da76dbb28b3bd2d56dcbdbaf4aa5e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9795b6c898304529ca3bc34145b23ea5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a9795b6c898304529ca3bc34145b23ea5">isOneValueProperty</a> () const </td></tr>
<tr class="memdesc:a9795b6c898304529ca3bc34145b23ea5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "one-value" property if its value list must always contain exactly one value.  <a href="#a9795b6c898304529ca3bc34145b23ea5"></a><br/></td></tr>
<tr class="separator:a9795b6c898304529ca3bc34145b23ea5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b6812da7751667518cd2a282da545c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ad3b6812da7751667518cd2a282da545c">isOneObjectProperty</a> () const </td></tr>
<tr class="memdesc:ad3b6812da7751667518cd2a282da545c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "one-object" property if it is a "one-value" property and it contains an Object-derived value.  <a href="#ad3b6812da7751667518cd2a282da545c"></a><br/></td></tr>
<tr class="separator:ad3b6812da7751667518cd2a282da545c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56581f4582e334d3c1caa6bb69aee6d3 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a56581f4582e334d3c1caa6bb69aee6d3">size</a> () const </td></tr>
<tr class="memdesc:a56581f4582e334d3c1caa6bb69aee6d3 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of values currently in this property's value list.  <a href="#a56581f4582e334d3c1caa6bb69aee6d3"></a><br/></td></tr>
<tr class="separator:a56581f4582e334d3c1caa6bb69aee6d3 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216316d68bb344424cead7db1ac71264 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a216316d68bb344424cead7db1ac71264">empty</a> () const </td></tr>
<tr class="memdesc:a216316d68bb344424cead7db1ac71264 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this property's value list is currently empty.  <a href="#a216316d68bb344424cead7db1ac71264"></a><br/></td></tr>
<tr class="separator:a216316d68bb344424cead7db1ac71264 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec8c00426c6841139be00515e749713 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a5ec8c00426c6841139be00515e749713">clear</a> ()</td></tr>
<tr class="memdesc:a5ec8c00426c6841139be00515e749713 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the value list for this property; fails if zero is not an allowable size for this property.  <a href="#a5ec8c00426c6841139be00515e749713"></a><br/></td></tr>
<tr class="separator:a5ec8c00426c6841139be00515e749713 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed651c70584d597daa389f197eb5ebd5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#aed651c70584d597daa389f197eb5ebd5">getValueAsObject</a> (int index=-1) const =0</td></tr>
<tr class="memdesc:aed651c70584d597daa389f197eb5ebd5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an object property, the values can be obtained as references to the abstract base class <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> from which all the objects derive.  <a href="#aed651c70584d597daa389f197eb5ebd5"></a><br/></td></tr>
<tr class="separator:aed651c70584d597daa389f197eb5ebd5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66ced70e8820a21c6f0f4c90f155aff inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ac66ced70e8820a21c6f0f4c90f155aff">updValueAsObject</a> (int index=-1)=0</td></tr>
<tr class="memdesc:ac66ced70e8820a21c6f0f4c90f155aff inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get writable access to an existing object value.  <a href="#ac66ced70e8820a21c6f0f4c90f155aff"></a><br/></td></tr>
<tr class="separator:ac66ced70e8820a21c6f0f4c90f155aff inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a11f2382a5216af4dbe49209e7ccef inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ab9a11f2382a5216af4dbe49209e7ccef">setValueAsObject</a> (const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;obj, int index=-1)=0</td></tr>
<tr class="memdesc:ab9a11f2382a5216af4dbe49209e7ccef inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects.">Set</a> the indicated value element to a new copy of the supplied object.  <a href="#ab9a11f2382a5216af4dbe49209e7ccef"></a><br/></td></tr>
<tr class="separator:ab9a11f2382a5216af4dbe49209e7ccef inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e44476b24c4b6830df297b8d78c7f5d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4e44476b24c4b6830df297b8d78c7f5d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a4e44476b24c4b6830df297b8d78c7f5d">getValue</a> (int index=-1) const </td></tr>
<tr class="memdesc:a4e44476b24c4b6830df297b8d78c7f5d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the values in this property as type T; this works only if the underlying concrete property stores type T and if the indexed element is present, otherwise throws an exception.  <a href="#a4e44476b24c4b6830df297b8d78c7f5d"></a><br/></td></tr>
<tr class="separator:a4e44476b24c4b6830df297b8d78c7f5d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a08cd08421dc135dface6cb9fb3d1e1c1">updValue</a> (int index=-1)</td></tr>
<tr class="memdesc:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to one of the values in this property as type T; this works only if the underlying concrete property is actually of type T and the indexed element is present.  <a href="#a08cd08421dc135dface6cb9fb3d1e1c1"></a><br/></td></tr>
<tr class="separator:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a05726a6ab0bee46b8f2b07a8931fd90a">appendValue</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new value of type T to the end of the list of values currently contained in this property.  <a href="#a05726a6ab0bee46b8f2b07a8931fd90a"></a><br/></td></tr>
<tr class="separator:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7a234feb91cb9e416ceaaff20586b17b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a7a234feb91cb9e416ceaaff20586b17b">isA</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;prop)</td></tr>
<tr class="memdesc:a7a234feb91cb9e416ceaaff20586b17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> references a concrete property of this type (Property&lt;T&gt;).  <a href="#a7a234feb91cb9e416ceaaff20586b17b"></a><br/></td></tr>
<tr class="separator:a7a234feb91cb9e416ceaaff20586b17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9729da476501b3fb9cfcdcf16f531e7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ac9729da476501b3fb9cfcdcf16f531e7">getAs</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;prop)</td></tr>
<tr class="memdesc:ac9729da476501b3fb9cfcdcf16f531e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a concrete property of this type (Property&lt;T&gt;).  <a href="#ac9729da476501b3fb9cfcdcf16f531e7"></a><br/></td></tr>
<tr class="separator:ac9729da476501b3fb9cfcdcf16f531e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac416f4ac135fcadc1a35b47b3cd36f0b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ac416f4ac135fcadc1a35b47b3cd36f0b">updAs</a> (<a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;prop)</td></tr>
<tr class="memdesc:ac416f4ac135fcadc1a35b47b3cd36f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a writable concrete property of this type (Property&lt;T&gt;).  <a href="#ac416f4ac135fcadc1a35b47b3cd36f0b"></a><br/></td></tr>
<tr class="separator:ac416f4ac135fcadc1a35b47b3cd36f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad82967fdf85fb260a2f204ee56c78e39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ad82967fdf85fb260a2f204ee56c78e39">OpenSim_DECLARE_PROPERTY</a>(name, T, comment)</td></tr>
<tr class="memdesc:ad82967fdf85fb260a2f204ee56c78e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a required, single-value property of the given <em>name</em> and type <em>T</em>, with an associated <em>comment</em>.  <a href="#ad82967fdf85fb260a2f204ee56c78e39"></a><br/></td></tr>
<tr class="separator:ad82967fdf85fb260a2f204ee56c78e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abddd12d20ea11b5fbbed0f0115423252"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#abddd12d20ea11b5fbbed0f0115423252">OpenSim_DECLARE_UNNAMED_PROPERTY</a>(T, comment)</td></tr>
<tr class="memdesc:abddd12d20ea11b5fbbed0f0115423252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a required, unnamed property holding exactly one object of type T derived from OpenSim's <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> class and identified by that object's class name rather than a property name.  <a href="#abddd12d20ea11b5fbbed0f0115423252"></a><br/></td></tr>
<tr class="separator:abddd12d20ea11b5fbbed0f0115423252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cd978daf1e37ebe7affdf82a4a3f74"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a68cd978daf1e37ebe7affdf82a4a3f74">OpenSim_DECLARE_OPTIONAL_PROPERTY</a>(name, T, comment)</td></tr>
<tr class="memdesc:a68cd978daf1e37ebe7affdf82a4a3f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a property of the given <em>name</em> containing an optional value of the given type T (that is, the value list can be of length 0 or 1 only).  <a href="#a68cd978daf1e37ebe7affdf82a4a3f74"></a><br/></td></tr>
<tr class="separator:a68cd978daf1e37ebe7affdf82a4a3f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae007fd298ed8e4b9c4b8e0a548afe4b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ae007fd298ed8e4b9c4b8e0a548afe4b7">OpenSim_DECLARE_LIST_PROPERTY</a>(name, T, comment)</td></tr>
<tr class="memdesc:ae007fd298ed8e4b9c4b8e0a548afe4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a property of the given <em>name</em> containing a variable-length list of values of the given type T.  <a href="#ae007fd298ed8e4b9c4b8e0a548afe4b7"></a><br/></td></tr>
<tr class="separator:ae007fd298ed8e4b9c4b8e0a548afe4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb95e049db0d54eab5220682a293be1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#aafb95e049db0d54eab5220682a293be1">OpenSim_DECLARE_LIST_PROPERTY_SIZE</a>(name, T, listSize, comment)</td></tr>
<tr class="memdesc:aafb95e049db0d54eab5220682a293be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a property of the given <em>name</em> containing a list of values of the given type T, with the number of values in the list restricted to be exactly <em>listSize</em> (&gt; 0) elements, no more or less.  <a href="#aafb95e049db0d54eab5220682a293be1"></a><br/></td></tr>
<tr class="separator:aafb95e049db0d54eab5220682a293be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1402dc49f1e702f6a037f7cf3a8e8fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ae1402dc49f1e702f6a037f7cf3a8e8fc">OpenSim_DECLARE_LIST_PROPERTY_ATLEAST</a>(name, T, minSize, comment)</td></tr>
<tr class="memdesc:ae1402dc49f1e702f6a037f7cf3a8e8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a property of the given <em>name</em> containing a list of values of the given type T, with the number of values required to be at least <em>minSize</em> (&gt; 0) elements.  <a href="#ae1402dc49f1e702f6a037f7cf3a8e8fc"></a><br/></td></tr>
<tr class="separator:ae1402dc49f1e702f6a037f7cf3a8e8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85da32f8b1752e0254f8e7293af985c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a85da32f8b1752e0254f8e7293af985c6">OpenSim_DECLARE_LIST_PROPERTY_ATMOST</a>(name, T, maxSize, comment)</td></tr>
<tr class="memdesc:a85da32f8b1752e0254f8e7293af985c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a property of the given <em>name</em> containing a list of values of the given type T, with the number of values in the list restricted to be no more than <em>maxSize</em> (&gt; 0) elements.  <a href="#a85da32f8b1752e0254f8e7293af985c6"></a><br/></td></tr>
<tr class="separator:a85da32f8b1752e0254f8e7293af985c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11154a9a04d2504b427e18fc718741d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a11154a9a04d2504b427e18fc718741d0">OpenSim_DECLARE_LIST_PROPERTY_RANGE</a>(name, T, minSize, maxSize, comment)</td></tr>
<tr class="memdesc:a11154a9a04d2504b427e18fc718741d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a property of the given <em>name</em> containing a list of values of the given type T, with the number of values in the list restricted to be in the range <em>minSize</em> (&gt; 0) to <em>maxSize</em> (&gt; <em>minSize</em>).  <a href="#a11154a9a04d2504b427e18fc718741d0"></a><br/></td></tr>
<tr class="separator:a11154a9a04d2504b427e18fc718741d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classOpenSim_1_1AbstractProperty"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classOpenSim_1_1AbstractProperty')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classOpenSim_1_1AbstractProperty.html">OpenSim::AbstractProperty</a></td></tr>
<tr class="memitem:a4b9addff7a03a165a5b1871322072ed5 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a4b9addff7a03a165a5b1871322072ed5">AbstractProperty</a> ()</td></tr>
<tr class="separator:a4b9addff7a03a165a5b1871322072ed5 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fe5ebe73e842f4c1ecd9cdbb2ce6da inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a55fe5ebe73e842f4c1ecd9cdbb2ce6da">AbstractProperty</a> (const std::string &amp;name, const std::string &amp;comment)</td></tr>
<tr class="separator:a55fe5ebe73e842f4c1ecd9cdbb2ce6da inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721847e1d058eecb6b54f6a0afaa6ffd inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a721847e1d058eecb6b54f6a0afaa6ffd">isEqualTo</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;other) const =0</td></tr>
<tr class="memdesc:a721847e1d058eecb6b54f6a0afaa6ffd inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5a801d683ef4f717be82244c1b59678d" title="Compare this property with another one; this is primarily used for testing.">equals()</a> method will have already done a lot of checking prior to calling this method, including verifying that both values are non-default and that the value lists are the same size; the concrete property need only compare the values.  <a href="#a721847e1d058eecb6b54f6a0afaa6ffd"></a><br/></td></tr>
<tr class="separator:a721847e1d058eecb6b54f6a0afaa6ffd inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa9140e7f33c76fd39546c8899e2f05 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#affa9140e7f33c76fd39546c8899e2f05">readFromXMLElement</a> (SimTK::Xml::Element &amp;propertyElement, int versionNumber)=0</td></tr>
<tr class="memdesc:affa9140e7f33c76fd39546c8899e2f05 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a new value for this property from the XML element <em>propertyElement</em>.  <a href="#affa9140e7f33c76fd39546c8899e2f05"></a><br/></td></tr>
<tr class="separator:affa9140e7f33c76fd39546c8899e2f05 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad006b81fe8f3d7c7cc402cc84b17c16 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#aad006b81fe8f3d7c7cc402cc84b17c16">writeToXMLElement</a> (SimTK::Xml::Element &amp;propertyElement) const =0</td></tr>
<tr class="memdesc:aad006b81fe8f3d7c7cc402cc84b17c16 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a serialized representation of this property by writing its value to the given XML property element.  <a href="#aad006b81fe8f3d7c7cc402cc84b17c16"></a><br/></td></tr>
<tr class="separator:aad006b81fe8f3d7c7cc402cc84b17c16 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80913f153f09fa3e8a2f62f255a2c659 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a80913f153f09fa3e8a2f62f255a2c659">getNumValues</a> () const =0</td></tr>
<tr class="memdesc:a80913f153f09fa3e8a2f62f255a2c659 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">How may values are currently stored in this property? If this is an object property you can use this with <a class="el" href="classOpenSim_1_1AbstractProperty.html#aed651c70584d597daa389f197eb5ebd5" title="For an object property, the values can be obtained as references to the abstract base class Object fr...">getValueAsObject()</a> to iterate over the contained objects.  <a href="#a80913f153f09fa3e8a2f62f255a2c659"></a><br/></td></tr>
<tr class="separator:a80913f153f09fa3e8a2f62f255a2c659 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac821e78df89632d595e2db657a7986ea inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ac821e78df89632d595e2db657a7986ea">clearValues</a> ()=0</td></tr>
<tr class="memdesc:ac821e78df89632d595e2db657a7986ea inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the concrete property allows it, clear the value list.  <a href="#ac821e78df89632d595e2db657a7986ea"></a><br/></td></tr>
<tr class="separator:ac821e78df89632d595e2db657a7986ea inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2afdbd068a6c0c8d1d36af0983e933 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a5d2afdbd068a6c0c8d1d36af0983e933">isAcceptableObjectTag</a> (const std::string &amp;objectTypeTag) const =0</td></tr>
<tr class="memdesc:a5d2afdbd068a6c0c8d1d36af0983e933 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given string is the XML tag name for one of the Object-derived types that is allowed by this property.  <a href="#a5d2afdbd068a6c0c8d1d36af0983e933"></a><br/></td></tr>
<tr class="separator:a5d2afdbd068a6c0c8d1d36af0983e933 inherit pro_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class OpenSim::Property&lt; T &gt;</h3>

<p>A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T. </p>
<p>The number of values allowed in the list is an attribute of the property; often it is just a single value. Properties are owned by classes that derive from OpenSim's serializable <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> base class. The documentation here is most useful for developers who are interested in creating a new <a class="el" href="classOpenSim_1_1ModelComponent.html" title="This defines the abstract ModelComponent class, which is used to add computational components to the ...">ModelComponent</a> or other serializable class derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.</p>
<p>A property's contained type T must be a serializable type. Serializable types come in two flavors:</p>
<ul>
<li>simple types (like int or string) for which serialization instructions have been provided, and</li>
<li>object types, in which case type T derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> and knows how to serialize itself.</li>
</ul>
<p>When T is a simple type we'll write T=S and refer to a Property&lt;S&gt; as a "simple property". When T is an object type, we'll write T=O and refer to a Property&lt;O&gt; as an "object property".</p>
<p>In case type O is a still-abstract Object-derived type like <a class="el" href="classOpenSim_1_1Function.html">Function</a> or <a class="el" href="classOpenSim_1_1Controller.html" title="Controller is an abstract ModelComponent that defines the interface for an OpenSim Controller...">Controller</a>, a Property&lt;O&gt; can hold a mix of any concrete objects derived from O (e.g., any <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> that can be dynamic_cast to a <a class="el" href="classOpenSim_1_1Function.html">Function</a> can be held by a Property&lt;<a class="el" href="classOpenSim_1_1Function.html">Function</a>&gt;).</p>
<p>The objects in an object property will themselves have properties so a Property&lt;O&gt; can be viewed as a node in the tree of objects that constitute an OpenSim <a class="el" href="classOpenSim_1_1Model.html" title="A concrete class that specifies the interface to a musculoskeletal model.">Model</a>. Simple properties Property&lt;S&gt; can be viewed as the terminal nodes of that tree. Properties are thus an integral part of the structure of an OpenSim <a class="el" href="classOpenSim_1_1Model.html" title="A concrete class that specifies the interface to a musculoskeletal model.">Model</a>; anything contained in a property is owned by that property; deleting the property deletes its contained objects. If you want to <em>reference</em> another <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> from within a property, use a string property to reference it by name; the result is a simple property. It is not permitted for type T to be a pointer or reference.</p>
<h3>XML file representation of properties</h3>
<p>The general representation for a Property&lt;T&gt; with name "prop_name" is </p>
<div class="fragment"><div class="line">&lt;prop_name&gt; T T ... T &lt;/prop_name&gt;</div>
</div><!-- fragment --><p> where "T" is the XML representation for objects of type T. Note that if T is an object type O, its representation follows the pattern </p>
<div class="fragment"><div class="line">&lt;OTypeName&gt; OContents &lt;/OTypeName&gt;</div>
</div><!-- fragment --><p> where <code>OTypeName</code> stands for the name of the concrete, Object-derived class being serialized, and <code>OContents</code> is the representation generated by that class when asked to serialize itself.</p>
<p>A Property&lt;O&gt; that is restricted to holding <em>exactly one</em> object of type O is called a "one-object property". It could be represented in XML as </p>
<div class="fragment"><div class="line">&lt;prop_name&gt; &lt;OTypeName&gt; OContents &lt;/OTypeName&gt; &lt;/prop_name&gt;</div>
</div><!-- fragment --><p> but we allow a more compact representation for one-object properties: </p>
<div class="fragment"><div class="line">&lt;OTypeName name=<span class="stringliteral">&quot;prop_name&quot;</span>&gt; OContents &lt;/OTypeName&gt;</div>
</div><!-- fragment --><p> In the one-object case it is also permissible for the property to be unnamed, in which case it may be referenced as though its name were the same as the object type name, and there is no separate "name" attribute. The XML representation for an unnamed property is just: </p>
<div class="fragment"><div class="line">&lt;OTypeName&gt; OContents &lt;/OTypeName&gt;</div>
</div><!-- fragment --><p> On input, if a name attribute is seen for an unnamed property it is ignored; only the object type name tag matters in the unnamed case. Note that only one-object properties can be unnamed, and no single OpenSim object can have more than one unnamed property of the same type.</p>
<h3>Property attributes</h3>
<p>In addition to the name and list of values, every property has the following attributes:</p>
<ul>
<li>A comment string, provided at the time the property is created.</li>
<li>The minimum and maximum number of values allowed.</li>
<li>A "used default value" flag.</li>
</ul>
<p>The "used default value" flag specifies that the value stored with this property was taken from a default object and not subsequently changed. A property with this flag set is not written out when a model is serialized.</p>
<h3>How to declare properties in your class declaration</h3>
<p>Properties are maintained in a <a class="el" href="classOpenSim_1_1PropertyTable.html" title="A property table is the container that an OpenSim Object uses to hold its properties (each derived fr...">PropertyTable</a> by OpenSim's <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> base class that is used for all serializable objects. Do not create Property objects directly; instead, use the provided macros to declare them in the class declarations for objects derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>. These macros should appear in the header file near the top of your class declaration, and should be preceded by Doxygen comments describing the property being declared.</p>
<p><b>Naming conventions:</b> OpenSim property names should use lower case letters with <code>words_separated_by_underscores</code>. In contrast, OpenSim object types begin with a capital letter and use camel case, that is, <code>MixedUpperAndLowerLikeThis</code>. This prevents any possible collisions between property names and object types, allowing both to be used as XML tag identifiers with no conflicts.</p>
<p>These are the most common forms of property declaration. Click on the macro names below for more information. </p>
<div class="fragment"><div class="line"><span class="comment">// Exactly one value required; this is the basic property type.</span></div>
<div class="line"><a class="code" href="classOpenSim_1_1Property.html#ad82967fdf85fb260a2f204ee56c78e39" title="Declare a required, single-value property of the given name and type T, with an associated comment...">OpenSim_DECLARE_PROPERTY</a>(name, T, <span class="stringliteral">&quot;property description&quot;</span>);</div>
<div class="line"><span class="comment">// Zero or one value only.</span></div>
<div class="line"><a class="code" href="classOpenSim_1_1Property.html#a68cd978daf1e37ebe7affdf82a4a3f74" title="Declare a property of the given name containing an optional value of the given type T (that is...">OpenSim_DECLARE_OPTIONAL_PROPERTY</a>(name, T, <span class="stringliteral">&quot;property description&quot;</span>);</div>
<div class="line"><span class="comment">// Zero or more values.</span></div>
<div class="line"><a class="code" href="classOpenSim_1_1Property.html#ae007fd298ed8e4b9c4b8e0a548afe4b7" title="Declare a property of the given name containing a variable-length list of values of the given type T...">OpenSim_DECLARE_LIST_PROPERTY</a>(name, T, <span class="stringliteral">&quot;property description&quot;</span>);</div>
</div><!-- fragment --><p> In the above, T may be a simple type S or object type O. In the case of a single-value property where type T is a type derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> (i.e., T=O), you can declare the property to be unnamed and instead use the class name of the object type O to identify the property: </p>
<div class="fragment"><div class="line"><span class="comment">// Exactly one value of object type O required.</span></div>
<div class="line"><a class="code" href="classOpenSim_1_1Property.html#abddd12d20ea11b5fbbed0f0115423252" title="Declare a required, unnamed property holding exactly one object of type T derived from OpenSim&#39;s Obje...">OpenSim_DECLARE_UNNAMED_PROPERTY</a>(O, <span class="stringliteral">&quot;property description&quot;</span>);</div>
</div><!-- fragment --><p> Only one unnamed property of a particular object type O may be declared in any given <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.</p>
<p>Finally, for list properties you can declare restrictions on the allowable list length: </p>
<div class="fragment"><div class="line"><span class="comment">// List must contain exactly listSize (&gt; 0) elements.</span></div>
<div class="line"><a class="code" href="classOpenSim_1_1Property.html#aafb95e049db0d54eab5220682a293be1" title="Declare a property of the given name containing a list of values of the given type T...">OpenSim_DECLARE_LIST_PROPERTY_SIZE</a>(name, T, listSize, </div>
<div class="line">                                   <span class="stringliteral">&quot;property description&quot;</span>);</div>
<div class="line"><span class="comment">// List must contain at least minSize (&gt; 0) elements.</span></div>
<div class="line"><a class="code" href="classOpenSim_1_1Property.html#ae1402dc49f1e702f6a037f7cf3a8e8fc" title="Declare a property of the given name containing a list of values of the given type T...">OpenSim_DECLARE_LIST_PROPERTY_ATLEAST</a>(name, T, minSize, </div>
<div class="line">                                      <span class="stringliteral">&quot;property description&quot;</span>);</div>
<div class="line"><span class="comment">// List must contain at most maxSize (&gt; 0) elements.</span></div>
<div class="line"><a class="code" href="classOpenSim_1_1Property.html#a85da32f8b1752e0254f8e7293af985c6" title="Declare a property of the given name containing a list of values of the given type T...">OpenSim_DECLARE_LIST_PROPERTY_ATMOST</a>(name, T, maxSize, </div>
<div class="line">                                     <span class="stringliteral">&quot;property description&quot;</span>);</div>
<div class="line"><span class="comment">// List must contain between minSize (&gt; 0) and maxSize (&gt;minSize) elements.</span></div>
<div class="line"><a class="code" href="classOpenSim_1_1Property.html#a11154a9a04d2504b427e18fc718741d0" title="Declare a property of the given name containing a list of values of the given type T...">OpenSim_DECLARE_LIST_PROPERTY_RANGE</a>(name, T, minSize, maxSize, </div>
<div class="line">                                    <span class="stringliteral">&quot;property description&quot;</span>);</div>
</div><!-- fragment --><p> Here is an example of an object declaring two properties, including our convention of documenting the property declarations in their own Doxygen group entitled "Property declarations". </p>
<pre class="fragment">*   class ActuatorWorkMeter : public ModelComponent {
*   OpenSim_DECLARE_CONCRETE_OBJECT(ActuatorWorkMeter, ModelComponent);
*   public:
*   //=======================================================================
*   // PROPERTIES
*   //=======================================================================
*       /** @name Property declarations
*       These are the serializable properties associated with this class. **/
*       /**@{**/
*       OpenSim_DECLARE_PROPERTY(actuator_name, std::string,
*           "The name of the actuator whose work use will be calculated.");
*       OpenSim_DECLARE_PROPERTY(initial_actuator_work, double,
*           "Initial value for work; normally zero.");
*       /**@}**/
*   //=======================================================================
*   // PUBLIC METHODS
*   //=======================================================================
*       ...
*   };
* </pre> <h3>How to construct properties in your constructors</h3>
<p>The constructors for your Object-derived class are required to construct and initialize the properties to whatever default values you want them to have. The above macros will have generated for each property a method for this purpose. If your property is named <em>prop_name</em>, then the method will be called constructProperty_<em>prop_name</em>(). (In the case of unnamed properties, the object type serves as <em>prop_name</em>.) The initial value is provided as an argument, which is optional for those properties that are allowed to contain a zero-length value list. Here are the various types of generated construction methods: </p>
<div class="fragment"><div class="line"><span class="comment">// Construct and initialize a single-valued property containing type T.</span></div>
<div class="line"><span class="keywordtype">void</span> constructProperty_prop_name(<span class="keyword">const</span> T&amp; value);</div>
<div class="line"><span class="comment">// Construct a property with a zero-length value list. </span></div>
<div class="line"><span class="keywordtype">void</span> constructProperty_prop_name();</div>
<div class="line"><span class="comment">// Construct a list property, initializing from a container.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>Container&gt;</div>
<div class="line"><span class="keywordtype">void</span> constructProperty_prop_name(<span class="keyword">const</span> Container&lt;T&gt;&amp; valueList);</div>
</div><!-- fragment --><p> The first form above is generated for basic, optional, and unnamed properties. The second, uninitialized form is generated for optional, unrestricted list, and list "atmost" properties, since those can accept a zero-element value list. The last form is generated for all list properties, regardless of size restriction; a runtime check verifies that size restrictions are met. That form accepts any container type that supports a size() method and random access element selection with operator[], such as std::vector&lt;T&gt;, OpenSim::Array&lt;T&gt;, or SimTK::Array_&lt;T&gt;.</p>
<p>The above methods are conventionally collected into a private method of each object class called <code>constructProperties()</code>. This method is then invoked from every constructor, <em>except</em> the copy constructor (which you normally should let the compiler generate, but see below).</p>
<h4>Copy constructor and copy assignment operator</h4>
<p>Your best bet is to use the compiler-generated default copy constructor and default copy assignment operator that you get whenever you leave these methods undefined. If you do that, all your properties and their associated local data will be copied automatically. It is worth some effort to design your objects so that their data members can copy and assign themselves correctly; you might find SimTK::ReferencePtr&lt;T&gt; and SimTK::ClonePtr&lt;T&gt; useful for getting pointer members to behave themselves properly.</p>
<p>However, if you do have to write your own copy constructor and copy assignment operator (and if you write one you must write the other also), the property table will still have been copied properly by your superclass, it is only the local property indices that you have to deal with. For that, each property has defined a method like: </p>
<div class="fragment"><div class="line"><span class="comment">// Copy the local data member associated with property prop_name.</span></div>
<div class="line"><span class="keywordtype">void</span> copyProperty_prop_name(<span class="keyword">const</span> Self&amp; source);</div>
</div><!-- fragment --><p> In the above, <code>Self</code> is the type of the object being defined and <code>source</code> is the argument that was passed to the containing copy constructor or copy assignment operator.</p>
<h3>Runtime access to property values</h3>
<p>The property declaration macros also generate per-property methods for getting access to property values or the the Property objects themselves. These inline methods are very fast and can be used whenever you need access to a property value. The following are generated for single-valued property types, including the basic, optional, and unnamed properties: </p>
<div class="fragment"><div class="line"><span class="comment">// Get a const reference to the value of a single-valued property </span></div>
<div class="line"><span class="comment">// named &quot;prop_name&quot; (basic, optional, unnamed properties only).</span></div>
<div class="line"><span class="keyword">const</span> T&amp; get_prop_name() <span class="keyword">const</span>;</div>
<div class="line"><span class="comment">// Same, but returns a writable reference.</span></div>
<div class="line">T&amp; upd_prop_name();</div>
<div class="line"><span class="comment">// Set the value of a single-valued property.</span></div>
<div class="line"><span class="keywordtype">void</span> set_prop_name(<span class="keyword">const</span> T&amp; value);</div>
</div><!-- fragment --><p>Additional methods are generated for list properties: </p>
<div class="fragment"><div class="line"><span class="comment">// Get a const reference to the i&#39;th element in a list property&#39;s value </span></div>
<div class="line"><span class="comment">// list.</span></div>
<div class="line"><span class="keyword">const</span> T&amp; get_prop_name(<span class="keywordtype">int</span> i) <span class="keyword">const</span>;</div>
<div class="line"><span class="comment">// Same, but returns a writable reference.</span></div>
<div class="line">T&amp; upd_prop_name(<span class="keywordtype">int</span> i);</div>
<div class="line"><span class="comment">// Set the i&#39;th element of a list property to the given value. Only </span></div>
<div class="line"><span class="comment">// allowed if the list currently has at least i elements, so no gaps can</span></div>
<div class="line"><span class="comment">// be created with this method.</span></div>
<div class="line"><span class="keywordtype">void</span> set_prop_name(<span class="keywordtype">int</span> i, <span class="keyword">const</span> T&amp; value);</div>
<div class="line"><span class="comment">// Use this to append one element to a list property&#39;s value list; the</span></div>
<div class="line"><span class="comment">// assigned index is returned.</span></div>
<div class="line"><span class="keywordtype">int</span> append_prop_name(<span class="keyword">const</span> T&amp; value);</div>
<div class="line"><span class="comment">// Use this to set all the values of a list-valued property.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>Container&gt;</div>
<div class="line"><span class="keywordtype">void</span> set_prop_name(<span class="keyword">const</span> Container&lt;T&gt;&amp; valueList);</div>
</div><!-- fragment --><p> The last form accepts any container that has a size() method and allows element access using operator[]. Runtime checks verify that the list length is within the allowable range for the property. Note that every property is considered to have a value list (even when restricted to one element) so the indexed forms above can also be used with single-valued properties as long as the index is zero.</p>
<p>To get access to the Property object rather than one of its values, the following methods are provided: </p>
<div class="fragment"><div class="line"><span class="comment">// Get a const reference to the Property&lt;T&gt; object for &quot;prop_name&quot;.</span></div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classProperty.html">Property&lt;T&gt;</a>&amp; getProperty_prop_name() <span class="keyword">const</span>;</div>
<div class="line"><span class="comment">// Same, but returns a writable reference.</span></div>
<div class="line"><a class="code" href="classProperty.html">Property&lt;T&gt;</a>&amp; updProperty_prop_name();</div>
</div><!-- fragment --><p>The Property&lt;T&gt; class acts as a container of values, and has the usual size(), empty(), and operator[] methods available so you can use getProperty...() above to get access to those methods. For example, to write out all the values of any property: </p>
<div class="fragment"><div class="line"><span class="comment">// Assumes type T can be written to a stream with operator&lt;&lt;.</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; getProperty_prop_name().size(); ++i)</div>
<div class="line">    std::cout &lt;&lt; get_prop_name(i) &lt;&lt; std::endl;</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">OpenSim::AbstractProperty</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Michael Sherman </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7f955ce364fd5c6a031263894a77c6a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::adoptAndAppendValue </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new value to the end of this property's value list, taking over ownership of the supplied heap-allocated object. </p>
<p>An exception is thrown if the property can't hold any more values. The index assigned to this value is returned. </p>

</div>
</div>
<a class="anchor" id="a8cebe3dfc74cb4f1d5158a4feb449e05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::appendValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a copy of the supplied <em>value</em> to the end of this property's value list. </p>
<p>An exception is thrown if the property can't hold any more values. The index assigned to this value is returned. </p>

</div>
</div>
<a class="anchor" id="a7f8d2992c9f493380aa3400a6f6ec9a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::appendValue </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a <em>copy</em> of the supplied <em>value</em> to the end of this property's value list. </p>
<p>An exception is thrown if the property can't hold any more values. The index assigned to this value is returned. Note that although we accept a pointer here, we do not take over ownership. See <a class="el" href="classOpenSim_1_1Property.html#a7f955ce364fd5c6a031263894a77c6a2" title="Add a new value to the end of this property&#39;s value list, taking over ownership of the supplied heap-...">adoptAndAppendValue()</a> if you want the property to take ownership. </p>

</div>
</div>
<a class="anchor" id="aeeca88c50f8115970c150889b1fd1ab3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>* <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a new, deep copy (clone) of this concrete property and return a pointer to the heap space. </p>
<p>Caller must delete the returned object when done with it. </p>

<p>Implements <a class="el" href="classOpenSim_1_1AbstractProperty.html#a2f3b26063ae74e345154c8695a7cd352">OpenSim::AbstractProperty</a>.</p>

</div>
</div>
<a class="anchor" id="a9169673da96ab5c0da51048ef331f134"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::findIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search the value list for an element that has the given <em>value</em> and return its index if found, otherwise -1. </p>
<p>This requires only that the template type T supports <a class="el" href="classOpenSim_1_1AbstractProperty.html#a47afa59d32288a346e4461ab0ae70b28" title="See the equals() method for the meaning of this operator.">operator==()</a>. This is a linear search so will take time proportional to the length of the value list. </p>

</div>
</div>
<a class="anchor" id="ac9729da476501b3fb9cfcdcf16f531e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::getAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a concrete property of this type (Property&lt;T&gt;). </p>
<p>An exception is thrown if this is not the right type only in DEBUG mode; see <a class="el" href="classOpenSim_1_1Property.html#a7a234feb91cb9e416ceaaff20586b17b" title="Return true if the given AbstractProperty references a concrete property of this type (Property&lt;T&gt;)...">isA()</a> if you need to check first. </p>

</div>
</div>
<a class="anchor" id="af97bf9a52c4547bc78c6efeed7496d20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt;::getTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <a class="el" href="structOpenSim_1_1Property_1_1TypeHelper.html" title="This is the generic definition of Property::TypeHelper to be used whenever T does not have a speciali...">TypeHelper</a>'s <a class="el" href="classOpenSim_1_1Property.html#af97bf9a52c4547bc78c6efeed7496d20" title="Use TypeHelper&#39;s getTypeName() to satisfy this pure virtual.">getTypeName()</a> to satisfy this pure virtual. </p>

<p>Implements <a class="el" href="classOpenSim_1_1AbstractProperty.html#a6d19ec8b81d27849e5cf0c41cdb9a4e6">OpenSim::AbstractProperty</a>.</p>

</div>
</div>
<a class="anchor" id="a66e1ead8242e6c28a48c1a99b849ecfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the selected value from this property's value list. </p>
<p>If the property is at most single valued then the <em>index</em> is optional and we'll behave as though index=0 were supplied. You can use the square bracket operator property[index] instead. </p>

</div>
</div>
<a class="anchor" id="a7a234feb91cb9e416ceaaff20586b17b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::isA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> references a concrete property of this type (Property&lt;T&gt;). </p>
<p>Note that for this to return true, the type T must be exactly the type used when the concrete property was allocated; it is not sufficient for T to be a more general base type from which the actual type was derived. </p>

</div>
</div>
<a class="anchor" id="aa9c23999672ed5ec0d74d140a67e89ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to a value of type T sets the value of this single-valued property to a copy of the supplied <em>value</em>; not allowed for a list property. </p>
<p>This does not invoke the assignment operator on the existing value. Instead, the value list is cleared and then replaced by the new value. This is synonymous with setValue(value). </p>

</div>
</div>
<a class="anchor" id="af3f1f6ba165cb5bd24cab98a22a8076c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;template&lt; class &gt; class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container. </p>
<p>The current value list is cleared before the assignment. This is synonymous with setValue(valueList). </p>

</div>
</div>
<a class="anchor" id="a7e132b9552b6c2a9cc8f6a33576fcb1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to one of the values in the value list. </p>
<p>This will throw an exception if the index does not refer to an already-existing value. This operator is synonymous with getValue(i). </p>

</div>
</div>
<a class="anchor" id="a567d26efb726367aca90f2534b032352"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a writable reference to one of the values in the value list. </p>
<p>This will throw an exception if the index does not refer to an already-existing value. This operator is synonymous with updValue(i). </p>

</div>
</div>
<a class="anchor" id="a3a8b68f9fa4cf67c5b9d681b4499d63e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the i'th value list element with a copy of the given <em>value</em>. </p>
<p>The index i must be between 0 and the current list length, meaning it is OK to refer one element past the last element. In that case the new <em>value</em> is appended to the list using <a class="el" href="classOpenSim_1_1Property.html#a8cebe3dfc74cb4f1d5158a4feb449e05" title="Append a copy of the supplied value to the end of this property&#39;s value list.">appendValue()</a>, which will throw an exception if the list is already at its maximum allowable size. In the case where index i refers to an existing element, a simple property will assign a new value to the existing element but an object property will delete the old object and replace it with a <a class="el" href="classOpenSim_1_1Property.html#aeeca88c50f8115970c150889b1fd1ab3" title="Make a new, deep copy (clone) of this concrete property and return a pointer to the heap space...">clone()</a> of the new one &ndash; it will <em>not</em> invoke the old object's assignment operator. That means that the concrete object type may be changed by this operation, provided it is still a type derived from object type T. If you want to invoke the existing value's assignment operator, use updValue(i) rather than setValue(i). </p>

</div>
</div>
<a class="anchor" id="aa92e55af5a211a210900438d858a481a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a new value for a single-valued property. </p>
<p>The current value (if any) is replaced, and size()==1 afterwards. An exception is thrown if this is a list property. </p>

</div>
</div>
<a class="anchor" id="a00355490194329012905b3407917fe9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;template&lt; class &gt; class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container. </p>
<p>The current value is cleared before the assignment. </p>

</div>
</div>
<a class="anchor" id="ac416f4ac135fcadc1a35b47b3cd36f0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::updAs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a writable concrete property of this type (Property&lt;T&gt;). </p>
<p>An exception is thrown if this is not the right type only in DEBUG mode; see <a class="el" href="classOpenSim_1_1Property.html#a7a234feb91cb9e416ceaaff20586b17b" title="Return true if the given AbstractProperty references a concrete property of this type (Property&lt;T&gt;)...">isA()</a> if you need to check first. </p>

</div>
</div>
<a class="anchor" id="ae597340fa1da9385439bbebf91a6a92a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::updValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the selected value from this property's value list. </p>
<p>If the property is at most single valued then the <em>index</em> is optional and we'll behave as though index=0 were supplied. You can use the square bracket operator property[index] instead. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ae007fd298ed8e4b9c4b8e0a548afe4b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_LIST_PROPERTY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">comment&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_DECLARE_LIST_PROPERTY_HELPER(name, T, comment,                  \</div>
<div class="line">                                         0, std::numeric_limits&lt;int&gt;::max())\</div>
<div class="line">    void constructProperty_##name()                                         \</div>
<div class="line">    {   PropertyIndex_##name = addListProperty&lt;T&gt;                           \</div>
<div class="line">           (#name, comment, 0, std::numeric_limits&lt;int&gt;::max()); }</div>
</div><!-- fragment -->
<p>Declare a property of the given <em>name</em> containing a variable-length list of values of the given type T. </p>
<p>The property may be constructed as empty, or with initialization to a templatized Container&lt;T&gt; for any Container that supports a size() method and operator[] element selection. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classOpenSim_1_1Property.html#aafb95e049db0d54eab5220682a293be1" title="Declare a property of the given name containing a list of values of the given type T...">OpenSim_DECLARE_LIST_PROPERTY_SIZE()</a> </dd>
<dd>
<a class="el" href="classOpenSim_1_1Property.html#ae1402dc49f1e702f6a037f7cf3a8e8fc" title="Declare a property of the given name containing a list of values of the given type T...">OpenSim_DECLARE_LIST_PROPERTY_ATLEAST()</a> </dd>
<dd>
<a class="el" href="classOpenSim_1_1Property.html#a85da32f8b1752e0254f8e7293af985c6" title="Declare a property of the given name containing a list of values of the given type T...">OpenSim_DECLARE_LIST_PROPERTY_ATMOST()</a> </dd>
<dd>
<a class="el" href="classOpenSim_1_1Property.html#a11154a9a04d2504b427e18fc718741d0" title="Declare a property of the given name containing a list of values of the given type T...">OpenSim_DECLARE_LIST_PROPERTY_RANGE()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae1402dc49f1e702f6a037f7cf3a8e8fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_LIST_PROPERTY_ATLEAST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">minSize, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">comment&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_DECLARE_LIST_PROPERTY_HELPER(name, T, comment,                  \</div>
<div class="line">                                (minSize), std::numeric_limits&lt;int&gt;::max())</div>
</div><!-- fragment -->
<p>Declare a property of the given <em>name</em> containing a list of values of the given type T, with the number of values required to be at least <em>minSize</em> (&gt; 0) elements. </p>
<p>Such a property must be initialized at construction, by providing a templatized Container&lt;T&gt; with at least <em>minSize</em> elements, using any Container that supports a size() method and operator[] element selection. </p>

</div>
</div>
<a class="anchor" id="a85da32f8b1752e0254f8e7293af985c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_LIST_PROPERTY_ATMOST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">maxSize, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">comment&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_DECLARE_LIST_PROPERTY_HELPER(name, T, comment, 0, (maxSize))    \</div>
<div class="line">    void constructProperty_##name()                                         \</div>
<div class="line">    {   PropertyIndex_##name = addListProperty&lt;T&gt;(#name, comment,           \</div>
<div class="line">                                                  0, (maxSize)); }</div>
</div><!-- fragment -->
<p>Declare a property of the given <em>name</em> containing a list of values of the given type T, with the number of values in the list restricted to be no more than <em>maxSize</em> (&gt; 0) elements. </p>
<p>This kind of property may optionally be initialized at construction, by providing a templatized Container&lt;T&gt; with no more than <em>maxSize</em> elements, using any Container that supports a size() method and operator[] element selection. </p>

</div>
</div>
<a class="anchor" id="a11154a9a04d2504b427e18fc718741d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_LIST_PROPERTY_RANGE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">minSize, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">maxSize, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">comment&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_DECLARE_LIST_PROPERTY_HELPER(name, T, comment,                  \</div>
<div class="line">                                        (minSize), (maxSize))</div>
</div><!-- fragment -->
<p>Declare a property of the given <em>name</em> containing a list of values of the given type T, with the number of values in the list restricted to be in the range <em>minSize</em> (&gt; 0) to <em>maxSize</em> (&gt; <em>minSize</em>). </p>
<p>This kind of property must be initialized with at least <em>minSize</em> values at construction. If you want to allow zero elements, so that initialization is optional, use OpenSim_DECLARE_PROPERTY_ATMOST() rather than this macro. </p>

</div>
</div>
<a class="anchor" id="aafb95e049db0d54eab5220682a293be1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_LIST_PROPERTY_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">listSize, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">comment&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_DECLARE_LIST_PROPERTY_HELPER(name, T, comment,                  \</div>
<div class="line">                                         (listSize), (listSize))</div>
</div><!-- fragment -->
<p>Declare a property of the given <em>name</em> containing a list of values of the given type T, with the number of values in the list restricted to be exactly <em>listSize</em> (&gt; 0) elements, no more or less. </p>
<p>A fixed-size property must be initialized at construction, by providing a templatized Container&lt;T&gt; with the right number of elements, using any Container that supports a size() method and operator[] element selection. </p>

</div>
</div>
<a class="anchor" id="a68cd978daf1e37ebe7affdf82a4a3f74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_OPTIONAL_PROPERTY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">comment&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_DECLARE_PROPERTY_HELPER(name,T)                                 \</div>
<div class="line">    void constructProperty_##name()                                         \</div>
<div class="line">    {   PropertyIndex_##name = addOptionalProperty&lt;T&gt;(#name, comment); }    \</div>
<div class="line">    void constructProperty_##name(<span class="keyword">const</span> T&amp; initValue)                       \</div>
<div class="line">    {   PropertyIndex_##name = addOptionalProperty&lt;T&gt;(#name, comment,       \</div>
<div class="line">                                                      initValue); }         \</div>
<div class="line">    const T&amp; get_##name() const                                             \</div>
<div class="line">    {   <span class="keywordflow">return</span> getProperty_##name().getValue(); }                           \</div>
<div class="line">    T&amp; upd_##name()                                                         \</div>
<div class="line">    {   <span class="keywordflow">return</span> updProperty_##name().updValue(); }                           \</div>
<div class="line">    void set_##name(<span class="keyword">const</span> T&amp; value)                                         \</div>
<div class="line">    {   updProperty_##name().setValue(value); }</div>
</div><!-- fragment -->
<p>Declare a property of the given <em>name</em> containing an optional value of the given type T (that is, the value list can be of length 0 or 1 only). </p>
<p>The property may be constructed as empty, or with initialization to a single value of type T. </p>

</div>
</div>
<a class="anchor" id="ad82967fdf85fb260a2f204ee56c78e39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_PROPERTY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">comment&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_DECLARE_PROPERTY_HELPER(name,T)                                 \</div>
<div class="line">    void constructProperty_##name(<span class="keyword">const</span> T&amp; initValue)                       \</div>
<div class="line">    {   PropertyIndex_##name = addProperty&lt;T&gt;(#name,comment,initValue); }   \</div>
<div class="line">    const T&amp; get_##name() const                                             \</div>
<div class="line">    {   <span class="keywordflow">return</span> getProperty_##name().getValue(); }                           \</div>
<div class="line">    T&amp; upd_##name()                                                         \</div>
<div class="line">    {   <span class="keywordflow">return</span> updProperty_##name().updValue(); }                           \</div>
<div class="line">    void set_##name(<span class="keyword">const</span> T&amp; value)                                         \</div>
<div class="line">    {   updProperty_##name().setValue(value); }</div>
</div><!-- fragment -->
<p>Declare a required, single-value property of the given <em>name</em> and type <em>T</em>, with an associated <em>comment</em>. </p>
<p>The value list for this property will always contain exactly one element, and the property must be initialized at construction. This macro, and the other similar macros, define several related methods. If the property name is my_prop_name, then the defined methods are:</p>
<ul>
<li>constructProperty_my_prop_name(initialValue)</li>
<li>getProperty_my_prop_name()</li>
<li>updProperty_my_prop_name()</li>
<li>get_my_prop_name()</li>
<li>upd_my_prop_name()</li>
<li>set_my_prop_name(value)</li>
</ul>
<p>For some property types, the initial value may be omitted during construction. A data member is also created but is intended for internal use only:</p>
<ul>
<li>PropertyIndex_my_prop_name holds the property table index for this property after it has been constructed </li>
</ul>

</div>
</div>
<a class="anchor" id="abddd12d20ea11b5fbbed0f0115423252"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_UNNAMED_PROPERTY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">comment&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_DECLARE_PROPERTY_HELPER(T,T)                                    \</div>
<div class="line">    void constructProperty_##T(<span class="keyword">const</span> T&amp; initValue)                          \</div>
<div class="line">    {   PropertyIndex_##T = addProperty&lt;T&gt;(<span class="stringliteral">&quot;&quot;</span>, comment, initValue); }       \</div>
<div class="line">    const T&amp; get_##T() const                                                \</div>
<div class="line">    {   <span class="keywordflow">return</span> getProperty_##T().getValue(); }                              \</div>
<div class="line">    T&amp; upd_##T()                                                            \</div>
<div class="line">    {   <span class="keywordflow">return</span> updProperty_##T().updValue(); }                              \</div>
<div class="line">    void set_##T(<span class="keyword">const</span> T&amp; value)                                            \</div>
<div class="line">    {   updProperty_##T().setValue(value); }</div>
</div><!-- fragment -->
<p>Declare a required, unnamed property holding exactly one object of type T derived from OpenSim's <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> class and identified by that object's class name rather than a property name. </p>
<p>At construction, this property must be initialized with an object of type T. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/Dev/src/OpenSimTrunk/OpenSim/Common/Property.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceOpenSim.html">OpenSim</a></li><li class="navelem"><a class="el" href="classOpenSim_1_1Property.html">Property</a></li>
    <li class="footer">Generated on Mon Jan 13 2014 10:13:08 for OpenSim by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
