<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenSim: OpenSim::Object Class Reference</title>
<link href="opensim.css" rel="stylesheet" type="text/css" />
<link href="lightbox.css" rel="stylesheet" type="text/css" />
<link href="bootstrap3/css/bootstrap.min.css" rel="stylesheet">
<script src="jquery-2.1.0.min.js"></script>
<script src="bootstrap3/js/bootstrap.min.js"></script>
<script src="lightbox.js"></script>
<script type="text/javascript" src="typeahead.min.js"></script>
<script src="hogan-2.0.0.js"></script>
<script type="text/javascript">
  window.onhashchange = function() {
  if (window.location.hash)
      window.scrollBy(0, -50);
  }
  if (window.location.hash)
  {
    window.scrollBy(0, -50);
  }
$( document ).ready(function() {
  $("#MSearchBox").hide();
  $("div.headertitle").addClass("page-header");
  $("div.title").addClass("h1");
  $('li > a[href="index.html"] > span').before("<i class='fa fa-cog'></i> ");
  $('li > a[href="index.html"] > span').text("OpenSim");
  $('li > a[href="modules.html"] > span').before("<i class='fa fa-square'></i> ");
  $('li > a[href="namespaces.html"] > span').before("<i class='fa fa-bars'></i> ");
  $('li > a[href="annotated.html"] > span').before("<i class='fa fa-list-ul'></i> ");
  $('li > a[href="classes.html"] > span').before("<i class='fa fa-book'></i> ");
  $('li > a[href="inherits.html"] > span').before("<i class='fa fa-sitemap'></i> ");
  $('li > a[href="functions.html"] > span').before("<i class='fa fa-list'></i> ");
  $('li > a[href="functions_func.html"] > span').before("<i class='fa fa-list'></i> ");
  $('li > a[href="functions_vars.html"] > span').before("<i class='fa fa-list'></i> ");
  $('li > a[href="functions_enum.html"] > span').before("<i class='fa fa-list'></i> ");
  $('li > a[href="functions_eval.html"] > span').before("<i class='fa fa-list'></i> ");
  $('img[src="ftv2ns.png"]').replaceWith('<span class="label label-danger">N</span> ');
  $('img[src="ftv2cl.png"]').replaceWith('<span class="label label-danger">C</span> ');
  $("ul.tablist").addClass("nav nav-pills nav-justified");
  $("ul.tablist").css("margin-top", "0.5em");
  $("ul.tablist").css("margin-bottom", "0.5em");
  $("li.current").addClass("active");
  $("iframe").attr("scrolling", "yes");
  $("#nav-path > ul").addClass("breadcrumb");
  $("table.params").addClass("table");
  $("div.ingroups").wrapInner("<small></small>");
  $("div.levels").css("margin", "0.5em");
  $("div.levels > span").addClass("btn btn-default btn-xs");
  $("div.levels > span").css("margin-right", "0.25em");
  $("table.directory").addClass("table table-striped");
  $("div.summary > a").addClass("btn btn-default btn-xs");
  $("table.fieldtable").addClass("table");
  $(".fragment").addClass("well");
  $(".memitem").addClass("panel panel-default");
  $(".memproto").addClass("panel-heading");
  $(".memdoc").addClass("panel-body");
  $("span.mlabel").addClass("label label-info");
  $("table.memberdecls").addClass("table");
  $("[class^=memitem]").addClass("active");
  $("div.ah").addClass("btn btn-default");
  $("span.mlabels").addClass("pull-right");
  $("table.mlabels").css("width", "100%")
  $("td.mlabels-right").addClass("pull-right");
  $("div.ttc").addClass("panel panel-info");
  $("div.ttname").addClass("panel-heading");
  $("div.ttdef,div.ttdoc,div.ttdeci").addClass("panel-body");
$("#search").typeahead([
    {
      name: 'opensim-search',
      valueKey: 'title',
      remote: { url: 'query?q=%QUERY&teaser=body&pagesize=1000',
      filter: function(p) {
        dat = [];
        for(i=0; i < p.hits.length; i++)
        {
          var pn = p.hits[i].document;
          pn.href = p.hits[i].id;
          dat.push(pn);
        }
        return dat;
      }
    },
      template: '<strong>{{title}}</strong><p>{{{teaser}}}</p>',
      engine: Hogan,
      limit: 1000
    }
    ]).on("typeahead:selected", (function (e, datum){
      window.location = datum.href;
    }));
    $('.typeahead.input-sm').siblings('input.tt-hint').addClass('hint-small');
    $('.typeahead.input-lg').siblings('input.tt-hint').addClass('hint-large');
  $.ajax({url : "ping", type: "GET", error : function() {
    var prt = $("#MSearchBox").parent();
    $(".twitter-typeahead").replaceWith($("#MSearchBox").show());
    prt.remove();
  }, success: function() {
    $("#MSearchBox").parent().remove();
    $(".nav>li").css("width", "266.667px");
  }   });
});
var initNavTree = function(a,b) { } 
function toggleVisibility(linkObj)
{
 var base = $(linkObj).attr('id');
 var summary = $('#'+base+'-summary');
 var content = $('#'+base+'-content');
 var trigger = $('#'+base+'-trigger');
 var src=$(trigger).attr('src');
 if (content.is(':visible')===true) {
   content.hide();
   summary.show();
   $(linkObj).addClass('closed').removeClass('opened');
   $(trigger).attr('src',src.substring(0,src.length-8)+'closed.png');
 } else {
   content.show();
   summary.hide();
   $(linkObj).removeClass('closed').addClass('opened');
   $(trigger).attr('src',src.substring(0,src.length-10)+'open.png');
 } 
 return false;
}
function updateStripes()
{
  $('table.directory tr').
       removeClass('even').filter(':visible:even').addClass('even');
}
function toggleLevel(level)
{
  $('table.directory tr').each(function(){ 
    var l = this.id.split('_').length-1;
    var i = $('#img'+this.id.substring(3));
    var a = $('#arr'+this.id.substring(3));
    if (l<level+1) {
      i.attr('src','ftv2folderopen.png');
      a.attr('src','ftv2mnode.png');
      $(this).show();
    } else if (l==level+1) {
      i.attr('src','ftv2folderclosed.png');
      a.attr('src','ftv2pnode.png');
      $(this).show();
    } else {
      $(this).hide();
    }
  });
  updateStripes();
}
function toggleFolder(id)
{
  //The clicked row
  var currentRow = $('#row_'+id);
  var currentRowImages = currentRow.find("img");
  //All rows after the clicked row
  var rows = currentRow.nextAll("tr");
  //Only match elements AFTER this one (can't hide elements before)
  var childRows = rows.filter(function() {
    var re = new RegExp('^row_'+id+'\\d+_$', "i"); //only one sub
    return this.id.match(re);
  });
  //First row is visible we are HIDING
  if (childRows.filter(':first').is(':visible')===true) {
    currentRowImages.filter("[id^=arr]").attr('src', 'ftv2pnode.png');
    currentRowImages.filter("[id^=img]").attr('src', 'ftv2folderclosed.png');
    rows.filter("[id^=row_"+id+"]").hide();
  } else { //We are SHOWING
    //All sub images
    var childImages = childRows.find("img");
    var childImg = childImages.filter("[id^=img]");
    var childArr = childImages.filter("[id^=arr]");
    currentRow.find("[id^=arr]").attr('src', 'ftv2mnode.png'); //open row
    currentRow.find("[id^=img]").attr('src', 'ftv2folderopen.png'); //open row
    childImg.attr('src','ftv2folderclosed.png'); //children closed
    childArr.attr('src','ftv2pnode.png'); //children closed
    childRows.show(); //show all children
  }
  updateStripes();
}
function toggleInherit(id)
{
  var rows = $('tr.inherit.'+id);
  var img = $('tr.inherit_header.'+id+' img');
  var src = $(img).attr('src');
  if (rows.filter(':first').is(':visible')===true) {
    rows.css('display','none');
    $(img).attr('src',src.substring(0,src.length-8)+'closed.png');
  } else {
    rows.css('display','table-row'); // using show() causes jump in firefox
    $(img).attr('src',src.substring(0,src.length-10)+'open.png');
  }
}
$(function() {
$(".dyncontent img").each(function () {
  $(this).wrap("<a href='" + $(this).attr("src") + "'></a>");
  $(".dyncontent a").click(function(e) { e.preventDefault(); $(this).ekkoLightbox();  });
} );
  diag = $("map").parent().children("a").children("img");
  if (diag != 'undefined')
  {
      diag.clone().load(function() { 
      ratio = diag.width() / this.width;
      $("area").each(function () {
          cr = $(this).attr("coords").split(",");
          for(l=0; l < cr.length; l++) {
            cr[l] = parseInt(cr[l]) * ratio;
          }
          $(this).attr("coords", cr.join(','));
      })
      console.log(ratio); 
    });
  }
});
</script>
<style type="text/css">
  body
  {
    width: 800px;
    margin: 0 auto;
  }
  img
  {
    max-width: 800px;
  }
  #container
  {
    margin-top: 70px;
  }
.twitter-typeahead .tt-hint
{
    display: block;
    height: 34px;
    padding: 6px 12px;
    font-size: 14px;
    line-height: 1.428571429;
    border: 1px solid transparent;
    border-radius:4px;
}
.twitter-typeahead .hint-small
{
    height: 30px;
    padding: 5px 10px;
    font-size: 12px;
    border-radius: 3px;
    line-height: 1.5;
}
.twitter-typeahead .hint-large
{
    height: 45px;
    padding: 10px 16px;
    font-size: 18px;
    border-radius: 6px;
    line-height: 1.33;
}
.twitter-typeahead {
    width: 100%;
    position: relative;
}
.twitter-typeahead .tt-query,
.twitter-typeahead .tt-hint {
    margin-bottom: 0;
    width:100%;
    height: 34px;
    position: absolute;
    top:0;
    left:0;
}
.twitter-typeahead .tt-hint {
    color:#a1a1a1;
    z-index: 1;
    padding: 6px 12px;
    border:1px solid transparent;
}
.twitter-typeahead .tt-query {
    z-index: 2;
    border-radius: 4px!important;
}
.tt-dropdown-menu {
    left: auto !important;
    right: 0px !important;
    overflow-y: auto;
    max-height: 400px;
    min-width: 160px;
    margin-top: 2px;
    padding: 5px 0;
    background-color: #fff;
    border: 1px solid #ccc;
    border: 1px solid rgba(0,0,0,.2);
    *border-right-width: 2px;
    *border-bottom-width: 2px;
    -webkit-border-radius: 6px;
    -moz-border-radius: 6px;
    border-radius: 6px;
    -webkit-box-shadow: 0 5px 10px rgba(0,0,0,.2);
    -moz-box-shadow: 0 5px 10px rgba(0,0,0,.2);
    box-shadow: 0 5px 10px rgba(0,0,0,.2);
    -webkit-background-clip: padding-box;
    -moz-background-clip: padding;
    background-clip: padding-box;
}
.tt-suggestion {
    display: block;
    padding: 3px 20px;
}
.tt-suggestion.tt-is-under-cursor {
    color: #fff;
    background-color: #0081c2;
    background-image: -moz-linear-gradient(top, #0088cc, #0077b3);
    background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#0088cc), to(#0077b3));
    background-image: -webkit-linear-gradient(top, #0088cc, #0077b3);
    background-image: -o-linear-gradient(top, #0088cc, #0077b3);
    background-image: linear-gradient(to bottom, #0088cc, #0077b3);
    background-repeat: repeat-x;
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc', endColorstr='#ff0077b3', GradientType=0)
}
.tt-suggestion.tt-is-under-cursor a {
    color: #fff;
}
.tt-suggestion p {
    margin: 0;
}
.sc-em
{
  font-weight: bold;
}
#MSearchResultsWindow
{
  top: 51px !important;
  position: fixed !important;
}
</style>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">OpenSim Documentation</a>
        </div>
          <form class="navbar-form navbar-right">
              <input type="search" placeholder="Search" class="form-control" id="search">
          </form>
      </div>
    </div>
  <div id="container">
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classOpenSim_1_1Object.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classOpenSim_1_1Object-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenSim::Object Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the base class for all OpenSim objects that are serializable (meaning they can be written to and read back from files).  
 <a href="classOpenSim_1_1Object.html#details">More...</a></p>

<p><code>#include &lt;Object.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OpenSim::Object:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classOpenSim_1_1Object.png" usemap="#OpenSim::Object_map" alt=""/>
  <map id="OpenSim::Object_map" name="OpenSim::Object_map">
<area href="classOpenSim_1_1AbstractTool.html" title="An abstract class for specifying the interface for an investigation. " alt="OpenSim::AbstractTool" shape="rect" coords="501,56,992,80"/>
<area href="classOpenSim_1_1Analysis.html" title="An abstract class for specifying the interface for an analysis plugin. " alt="OpenSim::Analysis" shape="rect" coords="501,112,992,136"/>
<area href="classOpenSim_1_1Bhargava2004MuscleMetabolicsProbe__MetabolicMuscleParameter.html" alt="OpenSim::Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter" shape="rect" coords="501,168,992,192"/>
<area href="classOpenSim_1_1BodyScale.html" title="A class implementing a set of parameters describing how to scale a body segment. " alt="OpenSim::BodyScale" shape="rect" coords="501,224,992,248"/>
<area href="classOpenSim_1_1Condition.html" title="A parent class for implementing an OpenSim Condition. " alt="OpenSim::Condition" shape="rect" coords="501,280,992,304"/>
<area href="classOpenSim_1_1Control.html" alt="OpenSim::Control" shape="rect" coords="501,336,992,360"/>
<area href="classOpenSim_1_1ControlLinearNode.html" alt="OpenSim::ControlLinearNode" shape="rect" coords="501,392,992,416"/>
<area href="classOpenSim_1_1DisplayGeometry.html" title="A class for representing the DisplayGeometry properties of an object. " alt="OpenSim::DisplayGeometry" shape="rect" coords="501,448,992,472"/>
<area href="classOpenSim_1_1Function.html" alt="OpenSim::Function" shape="rect" coords="501,504,992,528"/>
<area href="classOpenSim_1_1GenericModelMaker.html" title="A class implementing a set of parameters describing a generic musculoskeletal model. " alt="OpenSim::GenericModelMaker" shape="rect" coords="501,560,992,584"/>
<area href="classOpenSim_1_1IKTask.html" alt="OpenSim::IKTask" shape="rect" coords="501,616,992,640"/>
<area href="classOpenSim_1_1Marker.html" title="A class implementing a SIMM [mocap] marker. " alt="OpenSim::Marker" shape="rect" coords="501,672,992,696"/>
<area href="classOpenSim_1_1MarkerData.html" title="A class implementing a sequence of marker frames from a TRC/TRB file. " alt="OpenSim::MarkerData" shape="rect" coords="501,728,992,752"/>
<area href="classOpenSim_1_1MarkerFrame.html" title="A class implementing a frame of marker data from a TRC/TRB file. " alt="OpenSim::MarkerFrame" shape="rect" coords="501,784,992,808"/>
<area href="classOpenSim_1_1MarkerPair.html" alt="OpenSim::MarkerPair" shape="rect" coords="501,840,992,864"/>
<area href="classOpenSim_1_1MarkerPlacer.html" title="A class implementing a set of parameters describing how to place markers on a model (presumably after..." alt="OpenSim::MarkerPlacer" shape="rect" coords="501,896,992,920"/>
<area href="classOpenSim_1_1MarkerWeight.html" alt="OpenSim::MarkerWeight" shape="rect" coords="501,952,992,976"/>
<area href="classOpenSim_1_1Measurement.html" title="A class implementing a measurement (the distance between one or more pairs of markers, used to scale a model). " alt="OpenSim::Measurement" shape="rect" coords="501,1008,992,1032"/>
<area href="classOpenSim_1_1ModelComponent.html" title="This defines the abstract ModelComponent class, which is used to add computational components to the ..." alt="OpenSim::ModelComponent" shape="rect" coords="501,1064,992,1088"/>
<area href="classOpenSim_1_1ModelScaler.html" title="A class for scaling a model. " alt="OpenSim::ModelScaler" shape="rect" coords="501,1120,992,1144"/>
<area href="classOpenSim_1_1MuscleFirstOrderActivationDynamicModel.html" title="This is a muscle modeling utility class that computes the time derivative of activation using a first..." alt="OpenSim::MuscleFirstOrderActivationDynamicModel" shape="rect" coords="501,1176,992,1200"/>
<area href="classOpenSim_1_1MuscleFixedWidthPennationModel.html" title="This is a muscle modeling utility class containing kinematic equations that describe the deformation ..." alt="OpenSim::MuscleFixedWidthPennationModel" shape="rect" coords="501,1232,992,1256"/>
<area href="classOpenSim_1_1MuscleSecondOrderActivationDynamicModel.html" title="This function is a muscle modeling utility class that simulates dynamics of muscle force development ..." alt="OpenSim::MuscleSecondOrderActivationDynamicModel" shape="rect" coords="501,1288,992,1312"/>
<area href="classOpenSim_1_1ObjectGroup.html" title="A class implementing an object group. " alt="OpenSim::ObjectGroup" shape="rect" coords="501,1344,992,1368"/>
<area href="classOpenSim_1_1PathPoint.html" title="A class implementing a path point. " alt="OpenSim::PathPoint" shape="rect" coords="501,1400,992,1424"/>
<area href="classOpenSim_1_1Reference__.html" title="This base (abstract) class defines the interface for objects repsonsible in identifying a model outpu..." alt="OpenSim::Reference_&lt; T &gt;" shape="rect" coords="501,1456,992,1480"/>
<area href="classOpenSim_1_1Scale.html" alt="OpenSim::Scale" shape="rect" coords="501,1512,992,1536"/>
<area href="classOpenSim_1_1ScaleTool.html" title="A class implementing a set of parameters describing how to scale a model to fit a subject..." alt="OpenSim::ScaleTool" shape="rect" coords="501,1568,992,1592"/>
<area href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. " alt="OpenSim::Set&lt; T &gt;" shape="rect" coords="501,1624,992,1648"/>
<area href="classOpenSim_1_1SimbodyEngine.html" title="A wrapper class to use the SimTK Simbody dynamics engine as the underlying engine for OpenSim..." alt="OpenSim::SimbodyEngine" shape="rect" coords="501,1680,992,1704"/>
<area href="classOpenSim_1_1Solver.html" title="The base (abstract) class for a family of objects repsonsible for solving system equations (statics..." alt="OpenSim::Solver" shape="rect" coords="501,1736,992,1760"/>
<area href="classOpenSim_1_1SpatialTransform.html" title="A class encapsulating the spatial transformation between two bodies that defines the behaviour of a c..." alt="OpenSim::SpatialTransform" shape="rect" coords="501,1792,992,1816"/>
<area href="classOpenSim_1_1StorageInterface.html" alt="OpenSim::StorageInterface" shape="rect" coords="501,1848,992,1872"/>
<area href="classOpenSim_1_1Tool.html" title="A Tool is an OpenSim abstraction that encapsulates an analysis or series of modeling and analysis ste..." alt="OpenSim::Tool" shape="rect" coords="501,1904,992,1928"/>
<area href="classOpenSim_1_1TrackingTask.html" title="An abstract base class for specifying a target for a tracking problem. " alt="OpenSim::TrackingTask" shape="rect" coords="501,1960,992,1984"/>
<area href="classOpenSim_1_1TransformAxis.html" title="A class expressing a transformation of a child body in relation to a parent body along either a trans..." alt="OpenSim::TransformAxis" shape="rect" coords="501,2016,992,2040"/>
<area href="classOpenSim_1_1Umberger2010MuscleMetabolicsProbe__MetabolicMuscleParameter.html" alt="OpenSim::Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter" shape="rect" coords="501,2072,992,2096"/>
<area href="classOpenSim_1_1VectorFunction.html" alt="OpenSim::VectorFunction" shape="rect" coords="501,2128,992,2152"/>
<area href="classOpenSim_1_1VisibleObject.html" title="Class VisibleObject is intended to be used as the base class for all Visible objects that subclass Ob..." alt="OpenSim::VisibleObject" shape="rect" coords="501,2184,992,2208"/>
<area href="classOpenSim_1_1Reference__.html" alt="OpenSim::Reference_&lt; double &gt;" shape="rect" coords="501,2240,992,2264"/>
<area href="classOpenSim_1_1Reference__.html" alt="OpenSim::Reference_&lt; SimTK::Vec3 &gt;" shape="rect" coords="501,2296,992,2320"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Analysis &gt;" shape="rect" coords="501,2352,992,2376"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Bhargava2004MuscleMetabolicsProbe_MetabolicMuscleParameter &gt;" shape="rect" coords="501,2408,992,2432"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Body &gt;" shape="rect" coords="501,2464,992,2488"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; BodyScale &gt;" shape="rect" coords="501,2520,992,2544"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Constraint &gt;" shape="rect" coords="501,2576,992,2600"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; ContactGeometry &gt;" shape="rect" coords="501,2632,992,2656"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Control &gt;" shape="rect" coords="501,2688,992,2712"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Controller &gt;" shape="rect" coords="501,2744,992,2768"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Coordinate &gt;" shape="rect" coords="501,2800,992,2824"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; DisplayGeometry &gt;" shape="rect" coords="501,2856,992,2880"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; ExternalForce &gt;" shape="rect" coords="501,2912,992,2936"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Force &gt;" shape="rect" coords="501,2968,992,2992"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Function &gt;" shape="rect" coords="501,3024,992,3048"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; IKTask &gt;" shape="rect" coords="501,3080,992,3104"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Joint &gt;" shape="rect" coords="501,3136,992,3160"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Marker &gt;" shape="rect" coords="501,3192,992,3216"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; MarkerPair &gt;" shape="rect" coords="501,3248,992,3272"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Measurement &gt;" shape="rect" coords="501,3304,992,3328"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; ModelComponent &gt;" shape="rect" coords="501,3360,992,3384"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; OpenSim::Actuator &gt;" shape="rect" coords="501,3416,992,3440"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; OpenSim::Constraint &gt;" shape="rect" coords="501,3472,992,3496"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; OpenSim::Force &gt;" shape="rect" coords="501,3528,992,3552"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; OpenSim::MarkerWeight &gt;" shape="rect" coords="501,3584,992,3608"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; OpenSim::Muscle &gt;" shape="rect" coords="501,3640,992,3664"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; PathPoint &gt;" shape="rect" coords="501,3696,992,3720"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Probe &gt;" shape="rect" coords="501,3752,992,3776"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Scale &gt;" shape="rect" coords="501,3808,992,3832"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; TrackingTask &gt;" shape="rect" coords="501,3864,992,3888"/>
<area href="classOpenSim_1_1Set.html" alt="OpenSim::Set&lt; Umberger2010MuscleMetabolicsProbe_MetabolicMuscleParameter &gt;" shape="rect" coords="501,3920,992,3944"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5dc026c632531b193236dfaa65962d40"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a5dc026c632531b193236dfaa65962d40">~Object</a> ()</td></tr>
<tr class="memdesc:a5dc026c632531b193236dfaa65962d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for cleanup.  <a href="#a5dc026c632531b193236dfaa65962d40">More...</a><br/></td></tr>
<tr class="separator:a5dc026c632531b193236dfaa65962d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af221c900c5447df9928f1786469ef1b8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOpenSim_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#af221c900c5447df9928f1786469ef1b8">clone</a> () const =0</td></tr>
<tr class="memdesc:af221c900c5447df9928f1786469ef1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new heap-allocated copy of the concrete object to which this Object refers.  <a href="#af221c900c5447df9928f1786469ef1b8">More...</a><br/></td></tr>
<tr class="separator:af221c900c5447df9928f1786469ef1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f3462342f51392a34cb4f0787ae2b7"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a56f3462342f51392a34cb4f0787ae2b7">getConcreteClassName</a> () const =0</td></tr>
<tr class="memdesc:a56f3462342f51392a34cb4f0787ae2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class name of the concrete Object-derived class of the actual object referenced by this Object, as a string.  <a href="#a56f3462342f51392a34cb4f0787ae2b7">More...</a><br/></td></tr>
<tr class="separator:a56f3462342f51392a34cb4f0787ae2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad198104a9d49d467c58488a6964d6730"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOpenSim_1_1VisibleObject.html">VisibleObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ad198104a9d49d467c58488a6964d6730">getDisplayer</a> () const </td></tr>
<tr class="memdesc:ad198104a9d49d467c58488a6964d6730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods to support making the object displayable in the GUI or Visualizer Implemented only in few objects.  <a href="#ad198104a9d49d467c58488a6964d6730">More...</a><br/></td></tr>
<tr class="separator:ad198104a9d49d467c58488a6964d6730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe46905179b5d21f37c9b20f5ad70ffb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOpenSim_1_1VisibleObject.html">VisibleObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#abe46905179b5d21f37c9b20f5ad70ffb">updDisplayer</a> ()</td></tr>
<tr class="memdesc:abe46905179b5d21f37c9b20f5ad70ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">get Non const pointer to <a class="el" href="classOpenSim_1_1VisibleObject.html" title="Class VisibleObject is intended to be used as the base class for all Visible objects that subclass Ob...">VisibleObject</a>  <a href="#abe46905179b5d21f37c9b20f5ad70ffb">More...</a><br/></td></tr>
<tr class="separator:abe46905179b5d21f37c9b20f5ad70ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6690bb504728e0ba5d675178616005c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a6690bb504728e0ba5d675178616005c0">isEqualTo</a> (const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;aObject) const </td></tr>
<tr class="memdesc:a6690bb504728e0ba5d675178616005c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator wrapper for use from languages not supporting operator overloading.  <a href="#a6690bb504728e0ba5d675178616005c0">More...</a><br/></td></tr>
<tr class="separator:a6690bb504728e0ba5d675178616005c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1296dda9711e0e061fd29b88eacae796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a1296dda9711e0e061fd29b88eacae796">operator=</a> (const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;aObject)</td></tr>
<tr class="memdesc:a1296dda9711e0e061fd29b88eacae796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment copies he base class fields, including the properties.  <a href="#a1296dda9711e0e061fd29b88eacae796">More...</a><br/></td></tr>
<tr class="separator:a1296dda9711e0e061fd29b88eacae796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b3686d0084ddba34a754cf61996b71"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a96b3686d0084ddba34a754cf61996b71">operator==</a> (const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;aObject) const </td></tr>
<tr class="memdesc:a96b3686d0084ddba34a754cf61996b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if two objects are equal.  <a href="#a96b3686d0084ddba34a754cf61996b71">More...</a><br/></td></tr>
<tr class="separator:a96b3686d0084ddba34a754cf61996b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe4c39736b73c4df2f9c68c7a9f74a3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a3fe4c39736b73c4df2f9c68c7a9f74a3">operator&lt;</a> (const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;aObject) const </td></tr>
<tr class="memdesc:a3fe4c39736b73c4df2f9c68c7a9f74a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an ordering for objects so they can be put in sorted containers.  <a href="#a3fe4c39736b73c4df2f9c68c7a9f74a3">More...</a><br/></td></tr>
<tr class="separator:a3fe4c39736b73c4df2f9c68c7a9f74a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44921f417260a606255a162bfaa74e85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a44921f417260a606255a162bfaa74e85">setName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a44921f417260a606255a162bfaa74e85"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> the name of the <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.  <a href="#a44921f417260a606255a162bfaa74e85">More...</a><br/></td></tr>
<tr class="separator:a44921f417260a606255a162bfaa74e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5915b8c1d384df8ac19fd11a1fb21ccd"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a5915b8c1d384df8ac19fd11a1fb21ccd">getName</a> () const </td></tr>
<tr class="memdesc:a5915b8c1d384df8ac19fd11a1fb21ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.  <a href="#a5915b8c1d384df8ac19fd11a1fb21ccd">More...</a><br/></td></tr>
<tr class="separator:a5915b8c1d384df8ac19fd11a1fb21ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736967772e266744409791c21a94dd80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a736967772e266744409791c21a94dd80">setDescription</a> (const std::string &amp;description)</td></tr>
<tr class="memdesc:a736967772e266744409791c21a94dd80"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> description, a one-liner summary.  <a href="#a736967772e266744409791c21a94dd80">More...</a><br/></td></tr>
<tr class="separator:a736967772e266744409791c21a94dd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c82687e6065eaaded78637d6b962b3"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a95c82687e6065eaaded78637d6b962b3">getDescription</a> () const </td></tr>
<tr class="memdesc:a95c82687e6065eaaded78637d6b962b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get description, a one-liner summary.  <a href="#a95c82687e6065eaaded78637d6b962b3">More...</a><br/></td></tr>
<tr class="separator:a95c82687e6065eaaded78637d6b962b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33466c9415fae20658e0cb03919c9ea3"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a33466c9415fae20658e0cb03919c9ea3">getAuthors</a> () const </td></tr>
<tr class="memdesc:a33466c9415fae20658e0cb03919c9ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Authors of this <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.  <a href="#a33466c9415fae20658e0cb03919c9ea3">More...</a><br/></td></tr>
<tr class="separator:a33466c9415fae20658e0cb03919c9ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5543fa91645f86c336d121cf6da60dfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a5543fa91645f86c336d121cf6da60dfd">setAuthors</a> (const std::string &amp;authors)</td></tr>
<tr class="memdesc:a5543fa91645f86c336d121cf6da60dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> Authors of this object, call this method in your constructor if needed.  <a href="#a5543fa91645f86c336d121cf6da60dfd">More...</a><br/></td></tr>
<tr class="separator:a5543fa91645f86c336d121cf6da60dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e03d1cd0bda7673fc8d697a0114fc96"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a1e03d1cd0bda7673fc8d697a0114fc96">getReferences</a> () const </td></tr>
<tr class="memdesc:a1e03d1cd0bda7673fc8d697a0114fc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get references or publications to cite if using this object.  <a href="#a1e03d1cd0bda7673fc8d697a0114fc96">More...</a><br/></td></tr>
<tr class="separator:a1e03d1cd0bda7673fc8d697a0114fc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf59c40ec8751e01d736db3383cbe50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a3cf59c40ec8751e01d736db3383cbe50">setReferences</a> (const std::string &amp;references)</td></tr>
<tr class="memdesc:a3cf59c40ec8751e01d736db3383cbe50"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> references or publications to cite if using this object.  <a href="#a3cf59c40ec8751e01d736db3383cbe50">More...</a><br/></td></tr>
<tr class="separator:a3cf59c40ec8751e01d736db3383cbe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Registration of types and default objects</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods in this section deal with the requirement that all OpenSim types derived from Object must be registered and a default instance provided.</p>
<p>This enables reading these objects from XML files. You can also recognize now-obsolete names for objects and have them quietly mapped to their modern names using the <a class="el" href="classOpenSim_1_1Object.html#ad4f89d1f8a5d4b85dba51df9b207183b" title="Support versioning by associating the current Object type with an old name. ">renameType()</a> method. Rename can also be used programmatically to replace one registered type with another, because renaming occurs prior to object lookup. </p>
</div></td></tr>
<tr class="memitem:ace1fe7d9f4d7509b5d9e74fbe757b72d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ace1fe7d9f4d7509b5d9e74fbe757b72d">registerType</a> (const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;defaultObject)</td></tr>
<tr class="memdesc:ace1fe7d9f4d7509b5d9e74fbe757b72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an instance of a class; if the class is already registered it will be replaced.  <a href="#ace1fe7d9f4d7509b5d9e74fbe757b72d">More...</a><br/></td></tr>
<tr class="separator:ace1fe7d9f4d7509b5d9e74fbe757b72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f89d1f8a5d4b85dba51df9b207183b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ad4f89d1f8a5d4b85dba51df9b207183b">renameType</a> (const std::string &amp;oldTypeName, const std::string &amp;newTypeName)</td></tr>
<tr class="memdesc:ad4f89d1f8a5d4b85dba51df9b207183b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support versioning by associating the current Object type with an old name.  <a href="#ad4f89d1f8a5d4b85dba51df9b207183b">More...</a><br/></td></tr>
<tr class="separator:ad4f89d1f8a5d4b85dba51df9b207183b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa003166ace3f14af022b6650fc6fbd7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classOpenSim_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#afa003166ace3f14af022b6650fc6fbd7">getDefaultInstanceOfType</a> (const std::string &amp;concreteClassName)</td></tr>
<tr class="memdesc:afa003166ace3f14af022b6650fc6fbd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the default instance of the registered (concrete) Object whose class name is given, or NULL if the type is not registered.  <a href="#afa003166ace3f14af022b6650fc6fbd7">More...</a><br/></td></tr>
<tr class="separator:afa003166ace3f14af022b6650fc6fbd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a7df6eb433b4e130ce7aa63b8d3d7e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a77a7df6eb433b4e130ce7aa63b8d3d7e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a77a7df6eb433b4e130ce7aa63b8d3d7e">isObjectTypeDerivedFrom</a> (const std::string &amp;concreteClassName)</td></tr>
<tr class="memdesc:a77a7df6eb433b4e130ce7aa63b8d3d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given concrete object type represents a subclass of the template object type T, and thus could be referenced with a T*.  <a href="#a77a7df6eb433b4e130ce7aa63b8d3d7e">More...</a><br/></td></tr>
<tr class="separator:a77a7df6eb433b4e130ce7aa63b8d3d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd44aecebc85d2f98ff3adf443e284d0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOpenSim_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#afd44aecebc85d2f98ff3adf443e284d0">newInstanceOfType</a> (const std::string &amp;concreteClassName)</td></tr>
<tr class="memdesc:afd44aecebc85d2f98ff3adf443e284d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new instance of the concrete Object type whose class name is given as <em>concreteClassName</em>.  <a href="#afd44aecebc85d2f98ff3adf443e284d0">More...</a><br/></td></tr>
<tr class="separator:afd44aecebc85d2f98ff3adf443e284d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0296f61a06c319786a46d29743135d74"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a0296f61a06c319786a46d29743135d74">getRegisteredTypenames</a> (<a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; std::string &gt; &amp;typeNames)</td></tr>
<tr class="memdesc:a0296f61a06c319786a46d29743135d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the typenames registered so far.  <a href="#a0296f61a06c319786a46d29743135d74">More...</a><br/></td></tr>
<tr class="separator:a0296f61a06c319786a46d29743135d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f0039fba61c2fef84ba6bf8c07de6d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a34f0039fba61c2fef84ba6bf8c07de6d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a34f0039fba61c2fef84ba6bf8c07de6d">getRegisteredObjectsOfGivenType</a> (ArrayPtrs&lt; T &gt; &amp;rArray)</td></tr>
<tr class="memdesc:a34f0039fba61c2fef84ba6bf8c07de6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of pointers to the default instances of all registered (concrete) Object types that derive from a given Object-derived type that does not have to be concrete.  <a href="#a34f0039fba61c2fef84ba6bf8c07de6d">More...</a><br/></td></tr>
<tr class="separator:a34f0039fba61c2fef84ba6bf8c07de6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a84a2e7e58491709482729c7d52b90f21"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a84a2e7e58491709482729c7d52b90f21">DEFAULT_NAME</a></td></tr>
<tr class="memdesc:a84a2e7e58491709482729c7d52b90f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name used for default objects when they are serialized.  <a href="#a84a2e7e58491709482729c7d52b90f21">More...</a><br/></td></tr>
<tr class="separator:a84a2e7e58491709482729c7d52b90f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a620026774a4b0d36d93ed12a9451b356"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a620026774a4b0d36d93ed12a9451b356">Object</a> ()</td></tr>
<tr class="memdesc:a620026774a4b0d36d93ed12a9451b356"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor is only for use by constructors of derived types.  <a href="#a620026774a4b0d36d93ed12a9451b356">More...</a><br/></td></tr>
<tr class="separator:a620026774a4b0d36d93ed12a9451b356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1557e960a306925e8e809123f81a331"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#af1557e960a306925e8e809123f81a331">Object</a> (const std::string &amp;fileName, bool aUpdateFromXMLNode=true) SWIG_DECLARE_EXCEPTION</td></tr>
<tr class="memdesc:af1557e960a306925e8e809123f81a331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a file, to be called from other constructors that take a file as input.  <a href="#af1557e960a306925e8e809123f81a331">More...</a><br/></td></tr>
<tr class="separator:af1557e960a306925e8e809123f81a331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fad2c70cc33674ede31a20a29610fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a88fad2c70cc33674ede31a20a29610fc">Object</a> (const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;source)</td></tr>
<tr class="memdesc:a88fad2c70cc33674ede31a20a29610fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor is invoked automatically by derived classes with default copy constructors; otherwise it must be invoked explicitly.  <a href="#a88fad2c70cc33674ede31a20a29610fc">More...</a><br/></td></tr>
<tr class="separator:a88fad2c70cc33674ede31a20a29610fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ecc144d30a872d28ab63d82245da9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#af8ecc144d30a872d28ab63d82245da9b">Object</a> (SimTK::Xml::Element &amp;aElement)</td></tr>
<tr class="memdesc:af8ecc144d30a872d28ab63d82245da9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the base class portion of an Object from a given Xml element that describes this <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.  <a href="#af8ecc144d30a872d28ab63d82245da9b">More...</a><br/></td></tr>
<tr class="separator:af8ecc144d30a872d28ab63d82245da9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24322b3b4552de29ed0589a03ba7ad5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af24322b3b4552de29ed0589a03ba7ad5"><td class="memTemplItemLeft" align="right" valign="top">PropertyIndex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#af24322b3b4552de29ed0589a03ba7ad5">addProperty</a> (const std::string &amp;name, const std::string &amp;comment, const T &amp;value)</td></tr>
<tr class="memdesc:af24322b3b4552de29ed0589a03ba7ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a new single-value property of known type T, with the given <em>name</em>, associated <em>comment</em>, and initial <em>value</em>.  <a href="#af24322b3b4552de29ed0589a03ba7ad5">More...</a><br/></td></tr>
<tr class="separator:af24322b3b4552de29ed0589a03ba7ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33cd5e9f8e0b563ac29f7cf2565d5fc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae33cd5e9f8e0b563ac29f7cf2565d5fc"><td class="memTemplItemLeft" align="right" valign="top">PropertyIndex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ae33cd5e9f8e0b563ac29f7cf2565d5fc">addOptionalProperty</a> (const std::string &amp;name, const std::string &amp;comment)</td></tr>
<tr class="memdesc:ae33cd5e9f8e0b563ac29f7cf2565d5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an optional property, meaning it can contain either no value or a single value.  <a href="#ae33cd5e9f8e0b563ac29f7cf2565d5fc">More...</a><br/></td></tr>
<tr class="separator:ae33cd5e9f8e0b563ac29f7cf2565d5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affef953ecb6526d5de51f8d045229d79"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:affef953ecb6526d5de51f8d045229d79"><td class="memTemplItemLeft" align="right" valign="top">PropertyIndex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#affef953ecb6526d5de51f8d045229d79">addOptionalProperty</a> (const std::string &amp;name, const std::string &amp;comment, const T &amp;value)</td></tr>
<tr class="memdesc:affef953ecb6526d5de51f8d045229d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an optional property, meaning it can contain either no value or a single value.  <a href="#affef953ecb6526d5de51f8d045229d79">More...</a><br/></td></tr>
<tr class="separator:affef953ecb6526d5de51f8d045229d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5046920687929fbc0c0ec17681c146d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad5046920687929fbc0c0ec17681c146d"><td class="memTemplItemLeft" align="right" valign="top">PropertyIndex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ad5046920687929fbc0c0ec17681c146d">addListProperty</a> (const std::string &amp;name, const std::string &amp;comment, int minSize, int maxSize)</td></tr>
<tr class="memdesc:ad5046920687929fbc0c0ec17681c146d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a new list-valued property of known type T, with the given <em>name</em>, associated <em>comment</em>, minimum (==0) and maximum (&gt;0) allowable list lengths, and a zero-length initial value.  <a href="#ad5046920687929fbc0c0ec17681c146d">More...</a><br/></td></tr>
<tr class="separator:ad5046920687929fbc0c0ec17681c146d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e09382ab2bb833eba12c081f35b5a2d"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class Container&gt; </td></tr>
<tr class="memitem:a2e09382ab2bb833eba12c081f35b5a2d"><td class="memTemplItemLeft" align="right" valign="top">PropertyIndex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a2e09382ab2bb833eba12c081f35b5a2d">addListProperty</a> (const std::string &amp;name, const std::string &amp;comment, int minSize, int maxSize, const Container&lt; T &gt; &amp;valueList)</td></tr>
<tr class="memdesc:a2e09382ab2bb833eba12c081f35b5a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a new list-valued property as above, but assigning an initial value via some templatized container class that supports size() and indexing.  <a href="#a2e09382ab2bb833eba12c081f35b5a2d">More...</a><br/></td></tr>
<tr class="separator:a2e09382ab2bb833eba12c081f35b5a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a709cf81656cfd97bf37237bd03082"><td class="memItemLeft" align="right" valign="top">PropertyIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ae2a709cf81656cfd97bf37237bd03082">getPropertyIndex</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:ae2a709cf81656cfd97bf37237bd03082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a property by name and return its PropertyIndex if it is found.  <a href="#ae2a709cf81656cfd97bf37237bd03082">More...</a><br/></td></tr>
<tr class="separator:ae2a709cf81656cfd97bf37237bd03082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c14b84c3759aa0298bc772f06e9bbc6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8c14b84c3759aa0298bc772f06e9bbc6"><td class="memTemplItemLeft" align="right" valign="top">PropertyIndex&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a8c14b84c3759aa0298bc772f06e9bbc6">getPropertyIndex</a> () const </td></tr>
<tr class="memdesc:a8c14b84c3759aa0298bc772f06e9bbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an unnamed property by the type of object it contains, and return its PropertyIndex if it is found.  <a href="#a8c14b84c3759aa0298bc772f06e9bbc6">More...</a><br/></td></tr>
<tr class="separator:a8c14b84c3759aa0298bc772f06e9bbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a22e666ea5837cc9bfd8818b86b35e4ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1PropertySet.html">PropertySet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a22e666ea5837cc9bfd8818b86b35e4ce">_propertySet</a></td></tr>
<tr class="memdesc:a22e666ea5837cc9bfd8818b86b35e4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">OBSOLETE: <a class="el" href="classOpenSim_1_1Property__Deprecated.html">Property_Deprecated</a> set for serializable member variables of this and derived classes.  <a href="#a22e666ea5837cc9bfd8818b86b35e4ce">More...</a><br/></td></tr>
<tr class="separator:a22e666ea5837cc9bfd8818b86b35e4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a89a6ee4ca0d4b2502e469e5ae9bce0c4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a89a6ee4ca0d4b2502e469e5ae9bce0c4">operator&lt;&lt;</a> (std::ostream &amp;aOut, const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;aObject)</td></tr>
<tr class="memdesc:a89a6ee4ca0d4b2502e469e5ae9bce0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the type and name of this object into the given output stream.  <a href="#a89a6ee4ca0d4b2502e469e5ae9bce0c4">More...</a><br/></td></tr>
<tr class="separator:a89a6ee4ca0d4b2502e469e5ae9bce0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td colspan="2"><div class="groupHeader">Object Declaration Macros</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>One of these macros must appear as the first line of any class declaration that derives directly or indirectly from OpenSim's <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> class.</p>
<p>In almost all cases, the right macro to use is <code><a class="el" href="classOpenSim_1_1Object.html#a13075f96c92f1a0f18b791adf0fa255b" title="Macro to be included as the first line of the class declaration for any non-templatized, concrete class that derives from OpenSim::Object. ">OpenSim_DECLARE_CONCRETE_OBJECT()</a></code>.</p>
<p>Use of these macros provides:</p>
<ul>
<li>a public typedef Super that is the immediate parent class,</li>
<li>implementation of required <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> pure virtual methods, including the <a class="el" href="classOpenSim_1_1Object.html#af221c900c5447df9928f1786469ef1b8" title="Create a new heap-allocated copy of the concrete object to which this Object refers. ">clone()</a> method that will create a new heap-allocated copy of any concrete <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>,</li>
<li>uniform treatment of class names, which are used as tags in XML and for interfacing with Java using class names as strings to identify C++ objects. The static <a class="el" href="classOpenSim_1_1Object.html#a37944898e801cba2bf6f772272df2649" title="Return the name of this class as a string; i.e., &quot;Object&quot;. ">getClassName()</a> returns the name of any class, and the member <a class="el" href="classOpenSim_1_1Object.html#a56f3462342f51392a34cb4f0787ae2b7" title="Returns the class name of the concrete Object-derived class of the actual object referenced by this O...">getConcreteClassName()</a> returns the class name of the concrete object being referenced, and</li>
<li>an assortment of methods used only for interfacing with Java. </li>
</ul>
</div></td></tr>
<tr class="memitem:a13075f96c92f1a0f18b791adf0fa255b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a13075f96c92f1a0f18b791adf0fa255b">OpenSim_DECLARE_CONCRETE_OBJECT</a>(ConcreteClass, SuperClass)</td></tr>
<tr class="memdesc:a13075f96c92f1a0f18b791adf0fa255b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to be included as the first line of the class declaration for any non-templatized, concrete class that derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>.  <a href="#a13075f96c92f1a0f18b791adf0fa255b">More...</a><br/></td></tr>
<tr class="separator:a13075f96c92f1a0f18b791adf0fa255b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75c37552f6feacddf9fc1d9a7c08cbe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ab75c37552f6feacddf9fc1d9a7c08cbe">OpenSim_DECLARE_ABSTRACT_OBJECT</a>(ConcreteClass, SuperClass)</td></tr>
<tr class="memdesc:ab75c37552f6feacddf9fc1d9a7c08cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to be included as the first line of the class declaration for any still-abstract class that derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>.  <a href="#ab75c37552f6feacddf9fc1d9a7c08cbe">More...</a><br/></td></tr>
<tr class="separator:ab75c37552f6feacddf9fc1d9a7c08cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a016239bdc0a855927f706eca78876"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a04a016239bdc0a855927f706eca78876">OpenSim_DECLARE_CONCRETE_OBJECT_T</a>(ConcreteClass, TArg, SuperClass)</td></tr>
<tr class="memdesc:a04a016239bdc0a855927f706eca78876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to be included as the first line of the class declaration for any templatized, concrete class that derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>, like <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a>&lt;T&gt;.  <a href="#a04a016239bdc0a855927f706eca78876">More...</a><br/></td></tr>
<tr class="separator:a04a016239bdc0a855927f706eca78876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bc131913e859c757561270bb3adb86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#af7bc131913e859c757561270bb3adb86">OpenSim_DECLARE_ABSTRACT_OBJECT_T</a>(ConcreteClass, TArg, SuperClass)</td></tr>
<tr class="memdesc:af7bc131913e859c757561270bb3adb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to be included as the first line of the class declaration for any templatized, still-abstract class that derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>.  <a href="#af7bc131913e859c757561270bb3adb86">More...</a><br/></td></tr>
<tr class="separator:af7bc131913e859c757561270bb3adb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Public access to properties</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp84cfd03a6cabb2f00456b31934d59f99"></a>Methods in this section are for public access to the properties maintained by this <a class="el" href="namespaceOpenSim.html" title="An force that exerts a generalized force based on spring-like characteristics (stiffness and viscosit...">OpenSim</a> Object.</p>
<p>Properties are normally accessed through methods of the concrete Object-derived classes that are generated by the <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> declaration macros; see <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">OpenSim::Property</a> for information. However, when dealing with Objects from "the outside", as is done in the GUI, these methods allow access to properties via the property base class <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to support various type-independent property services. That is particularly useful for Object-containing properties since the objects can be obtained without knowing their concrete types. For simple types (e.g. int, std::string) you can only obtain the values if you know the expected type. For those types, or when you know the expected Object type, you can use the templatized methods to deal with the concrete values. </p>
</td></tr>
<tr class="memitem:aa298781dd5a5b3c892662ef73172f0bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#aa298781dd5a5b3c892662ef73172f0bf">getNumProperties</a> () const </td></tr>
<tr class="memdesc:aa298781dd5a5b3c892662ef73172f0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how many properties are stored with this Object.  <a href="#aa298781dd5a5b3c892662ef73172f0bf">More...</a><br/></td></tr>
<tr class="separator:aa298781dd5a5b3c892662ef73172f0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3135199b9122677080358606b672d8df"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a3135199b9122677080358606b672d8df">getPropertyByIndex</a> (int propertyIndex) const </td></tr>
<tr class="memdesc:a3135199b9122677080358606b672d8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to a property by its index number, returned as an <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a>.  <a href="#a3135199b9122677080358606b672d8df">More...</a><br/></td></tr>
<tr class="separator:a3135199b9122677080358606b672d8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f81ef13cb278c49785cbb2236cc2b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ac3f81ef13cb278c49785cbb2236cc2b0">updPropertyByIndex</a> (int propertyIndex)</td></tr>
<tr class="memdesc:ac3f81ef13cb278c49785cbb2236cc2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a writable reference to a property by its index number, returned as an <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a>.  <a href="#ac3f81ef13cb278c49785cbb2236cc2b0">More...</a><br/></td></tr>
<tr class="separator:ac3f81ef13cb278c49785cbb2236cc2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e325f974b4640ba3a61658d83a4e5bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a0e325f974b4640ba3a61658d83a4e5bc">hasProperty</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a0e325f974b4640ba3a61658d83a4e5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this Object has a property of any type with the given <em>name</em>, which must not be empty.  <a href="#a0e325f974b4640ba3a61658d83a4e5bc">More...</a><br/></td></tr>
<tr class="separator:a0e325f974b4640ba3a61658d83a4e5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a65abcee1fee7ef6a261f99c45e46d9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a1a65abcee1fee7ef6a261f99c45e46d9">getPropertyByName</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a1a65abcee1fee7ef6a261f99c45e46d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to a property by its name, returned as an <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a>.  <a href="#a1a65abcee1fee7ef6a261f99c45e46d9">More...</a><br/></td></tr>
<tr class="separator:a1a65abcee1fee7ef6a261f99c45e46d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62268af4017fc9d547ae718b3cb3733d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a62268af4017fc9d547ae718b3cb3733d">updPropertyByName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a62268af4017fc9d547ae718b3cb3733d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a writable reference to a property by its name, returned as an <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a>.  <a href="#a62268af4017fc9d547ae718b3cb3733d">More...</a><br/></td></tr>
<tr class="separator:a62268af4017fc9d547ae718b3cb3733d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6af5b2dc8e345c2a99a50f75ce12275"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab6af5b2dc8e345c2a99a50f75ce12275"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ab6af5b2dc8e345c2a99a50f75ce12275">hasProperty</a> () const </td></tr>
<tr class="memdesc:ab6af5b2dc8e345c2a99a50f75ce12275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this Object contains an unnamed, one-object property that contains objects of the given template type T.  <a href="#ab6af5b2dc8e345c2a99a50f75ce12275">More...</a><br/></td></tr>
<tr class="separator:ab6af5b2dc8e345c2a99a50f75ce12275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae569867dea47d552436ca887a580dd3c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae569867dea47d552436ca887a580dd3c"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ae569867dea47d552436ca887a580dd3c">getProperty</a> (const PropertyIndex &amp;index) const </td></tr>
<tr class="memdesc:ae569867dea47d552436ca887a580dd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get property of known type <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a>&lt;T&gt; as a const reference; the property must be present and have the right type.  <a href="#ae569867dea47d552436ca887a580dd3c">More...</a><br/></td></tr>
<tr class="separator:ae569867dea47d552436ca887a580dd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351933e7ddc7a7e761e2a8a9cd12728b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a351933e7ddc7a7e761e2a8a9cd12728b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a351933e7ddc7a7e761e2a8a9cd12728b">updProperty</a> (const PropertyIndex &amp;index)</td></tr>
<tr class="memdesc:a351933e7ddc7a7e761e2a8a9cd12728b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get property of known type <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a>&lt;T&gt; as a writable reference; the property must be present and have the right type.  <a href="#a351933e7ddc7a7e761e2a8a9cd12728b">More...</a><br/></td></tr>
<tr class="separator:a351933e7ddc7a7e761e2a8a9cd12728b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aff140025aa58def7bad8810a6c4652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a6aff140025aa58def7bad8810a6c4652">setObjectIsUpToDateWithProperties</a> ()</td></tr>
<tr class="memdesc:a6aff140025aa58def7bad8810a6c4652"><td class="mdescLeft">&#160;</td><td class="mdescRight">When an object is initialized using the current values of its properties, it can set a flag indicating that it is up to date.  <a href="#a6aff140025aa58def7bad8810a6c4652">More...</a><br/></td></tr>
<tr class="separator:a6aff140025aa58def7bad8810a6c4652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4e64da3072679681702cdb786c41cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a8e4e64da3072679681702cdb786c41cf">isObjectUpToDateWithProperties</a> () const </td></tr>
<tr class="memdesc:a8e4e64da3072679681702cdb786c41cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if no property's value has changed since the last time <a class="el" href="classOpenSim_1_1Object.html#a6aff140025aa58def7bad8810a6c4652" title="When an object is initialized using the current values of its properties, it can set a flag indicatin...">setObjectIsUpToDateWithProperties()</a> was called.  <a href="#a8e4e64da3072679681702cdb786c41cf">More...</a><br/></td></tr>
<tr class="separator:a8e4e64da3072679681702cdb786c41cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0586ab0764c0a94ead847bb0ca4c0eb3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a0586ab0764c0a94ead847bb0ca4c0eb3">PrintPropertyInfo</a> (std::ostream &amp;os, const std::string &amp;classNameDotPropertyName)</td></tr>
<tr class="memdesc:a0586ab0764c0a94ead847bb0ca4c0eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump formatted property information to a given output stream, useful for creating a "help" facility for registered objects.  <a href="#a0586ab0764c0a94ead847bb0ca4c0eb3">More...</a><br/></td></tr>
<tr class="separator:a0586ab0764c0a94ead847bb0ca4c0eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab93bb0a139e5e11f359d61fe1ae3e1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#aaab93bb0a139e5e11f359d61fe1ae3e1">PrintPropertyInfo</a> (std::ostream &amp;os, const std::string &amp;className, const std::string &amp;propertyName)</td></tr>
<tr class="memdesc:aaab93bb0a139e5e11f359d61fe1ae3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the other signature but the class name and property name are provided as two separate strings.  <a href="#aaab93bb0a139e5e11f359d61fe1ae3e1">More...</a><br/></td></tr>
<tr class="separator:aaab93bb0a139e5e11f359d61fe1ae3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
XML reading and writing</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd94c366a7fc08b78d390ea0e244310db"></a>These methods deal with writing out in-memory objects to XML files (serializing) and reading XML files to reconstruct in-memory objects (deserializing).</p>
</td></tr>
<tr class="memitem:abd740e38f08939be0c05b622b2a5f61e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#abd740e38f08939be0c05b622b2a5f61e">readObjectFromXMLNodeOrFile</a> (SimTK::Xml::Element &amp;objectElement, int versionNumber)</td></tr>
<tr class="memdesc:abd740e38f08939be0c05b622b2a5f61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">We're given an XML element from which we are to populate this Object.  <a href="#abd740e38f08939be0c05b622b2a5f61e">More...</a><br/></td></tr>
<tr class="separator:abd740e38f08939be0c05b622b2a5f61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988abda95a67bb454373a89fe38f2af7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a988abda95a67bb454373a89fe38f2af7">updateFromXMLNode</a> (SimTK::Xml::Element &amp;objectElement, int versionNumber)</td></tr>
<tr class="memdesc:a988abda95a67bb454373a89fe38f2af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method to deserialize an object from a SimTK::Xml::Element.  <a href="#a988abda95a67bb454373a89fe38f2af7">More...</a><br/></td></tr>
<tr class="separator:a988abda95a67bb454373a89fe38f2af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bad202ee6d57acbbcc28c2b51cf7413"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a0bad202ee6d57acbbcc28c2b51cf7413">updateXMLNode</a> (SimTK::Xml::Element &amp;parent)</td></tr>
<tr class="memdesc:a0bad202ee6d57acbbcc28c2b51cf7413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize this object into the XML node that represents it.  <a href="#a0bad202ee6d57acbbcc28c2b51cf7413">More...</a><br/></td></tr>
<tr class="separator:a0bad202ee6d57acbbcc28c2b51cf7413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d8a9b32fa174430a354c3508345bc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a10d8a9b32fa174430a354c3508345bc0">getInlined</a> () const </td></tr>
<tr class="memdesc:a10d8a9b32fa174430a354c3508345bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlined means an in-memory <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> that is not associated with an <a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a>.  <a href="#a10d8a9b32fa174430a354c3508345bc0">More...</a><br/></td></tr>
<tr class="separator:a10d8a9b32fa174430a354c3508345bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab419ca21895e653bffb4fc5b0ac3afa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ab419ca21895e653bffb4fc5b0ac3afa2">setInlined</a> (bool aInlined, const std::string &amp;aFileName=&quot;&quot;)</td></tr>
<tr class="memdesc:ab419ca21895e653bffb4fc5b0ac3afa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark this as inlined or not and optionally provide a file name to associate with the new <a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a> for the non-inline case.  <a href="#ab419ca21895e653bffb4fc5b0ac3afa2">More...</a><br/></td></tr>
<tr class="separator:ab419ca21895e653bffb4fc5b0ac3afa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54c991bb056d6cafe4c26d670c9c891"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ad54c991bb056d6cafe4c26d670c9c891">getDocumentFileName</a> () const </td></tr>
<tr class="memdesc:ad54c991bb056d6cafe4c26d670c9c891"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is a document associated with this object then return the file name maintained by the document.  <a href="#ad54c991bb056d6cafe4c26d670c9c891">More...</a><br/></td></tr>
<tr class="separator:ad54c991bb056d6cafe4c26d670c9c891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092550b5528d3d817022c045e4144183"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a092550b5528d3d817022c045e4144183">setAllPropertiesUseDefault</a> (bool aUseDefault)</td></tr>
<tr class="separator:a092550b5528d3d817022c045e4144183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb75c7ca31491448197278e589266c48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#abb75c7ca31491448197278e589266c48">print</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:abb75c7ca31491448197278e589266c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write this Object into an XML file of the given name; conventionally the suffix to use is ".osim".  <a href="#abb75c7ca31491448197278e589266c48">More...</a><br/></td></tr>
<tr class="separator:abb75c7ca31491448197278e589266c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e26741bc3518688164242c4b880c71"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#aa0e26741bc3518688164242c4b880c71">dump</a> (bool dumpName=false)</td></tr>
<tr class="memdesc:aa0e26741bc3518688164242c4b880c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">dump the XML representation of this Object into an std::string and return it.  <a href="#aa0e26741bc3518688164242c4b880c71">More...</a><br/></td></tr>
<tr class="separator:aa0e26741bc3518688164242c4b880c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d860a7849ddbb27885673dbf5dbf76"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOpenSim_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ab7d860a7849ddbb27885673dbf5dbf76">makeObjectFromFile</a> (const std::string &amp;fileName)</td></tr>
<tr class="memdesc:ab7d860a7849ddbb27885673dbf5dbf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an OpenSim object whose type is based on the tag at the root node of the XML file passed in.  <a href="#ab7d860a7849ddbb27885673dbf5dbf76">More...</a><br/></td></tr>
<tr class="separator:ab7d860a7849ddbb27885673dbf5dbf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2da63a45b146424737d00c128a8491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a1d2da63a45b146424737d00c128a8491">updateFromXMLDocument</a> ()</td></tr>
<tr class="memdesc:a1d2da63a45b146424737d00c128a8491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this method only if you're deserializing from a file and the object is at the top level; that is, primarily in constructors that take a file name as input.  <a href="#a1d2da63a45b146424737d00c128a8491">More...</a><br/></td></tr>
<tr class="separator:a1d2da63a45b146424737d00c128a8491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6cc3ab175f7fbd32e9bc001d5ba30a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#abb6cc3ab175f7fbd32e9bc001d5ba30a">setDocument</a> (<a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a> *doc)</td></tr>
<tr class="memdesc:abb6cc3ab175f7fbd32e9bc001d5ba30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unconditionally set the <a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a> associated with this object.  <a href="#abb6cc3ab175f7fbd32e9bc001d5ba30a">More...</a><br/></td></tr>
<tr class="separator:abb6cc3ab175f7fbd32e9bc001d5ba30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00afa73fcae409e8b8c993d3e977149f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a00afa73fcae409e8b8c993d3e977149f">getDocument</a> () const </td></tr>
<tr class="memdesc:a00afa73fcae409e8b8c993d3e977149f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the document (if any) associated with this object.  <a href="#a00afa73fcae409e8b8c993d3e977149f">More...</a><br/></td></tr>
<tr class="separator:a00afa73fcae409e8b8c993d3e977149f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5324b6c5432c4c37619afc29996136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#afd5324b6c5432c4c37619afc29996136">updDocument</a> ()</td></tr>
<tr class="memdesc:afd5324b6c5432c4c37619afc29996136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a writable pointer to the document (if any) associated with this object.  <a href="#afd5324b6c5432c4c37619afc29996136">More...</a><br/></td></tr>
<tr class="separator:afd5324b6c5432c4c37619afc29996136"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Advanced/Obscure</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6f4b33f6ba3a8f230d324ef379dcc191"></a>Methods in this section are for specialized purposes not of interest to most <a class="el" href="namespaceOpenSim.html" title="An force that exerts a generalized force based on spring-like characteristics (stiffness and viscosit...">OpenSim</a> API users.</p>
<p>For example, some of these are services needed by the <a class="el" href="namespaceOpenSim.html" title="An force that exerts a generalized force based on spring-like characteristics (stiffness and viscosit...">OpenSim</a> GUI which is written in Java. </p>
</td></tr>
<tr class="memitem:a5291e688292cba7a488b077e6dc64938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a5291e688292cba7a488b077e6dc64938">clearObjectIsUpToDateWithProperties</a> ()</td></tr>
<tr class="memdesc:a5291e688292cba7a488b077e6dc64938"><td class="mdescLeft">&#160;</td><td class="mdescRight">For testing or debugging purposes, manually clear the "object is up to 
date with respect to properties" flag.  <a href="#a5291e688292cba7a488b077e6dc64938">More...</a><br/></td></tr>
<tr class="separator:a5291e688292cba7a488b077e6dc64938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126f1d87df28a081c7b1c99bb477cb3b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a126f1d87df28a081c7b1c99bb477cb3b">isA</a> (const char *type) const </td></tr>
<tr class="memdesc:a126f1d87df28a081c7b1c99bb477cb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation returns true only if the supplied string is "Object"; each Object-derived class overrides this to match its own class name.  <a href="#a126f1d87df28a081c7b1c99bb477cb3b">More...</a><br/></td></tr>
<tr class="separator:a126f1d87df28a081c7b1c99bb477cb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c9abc33ff7e6f061e35c7e67e6eb14"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#ac3c9abc33ff7e6f061e35c7e67e6eb14">toString</a> () const </td></tr>
<tr class="memdesc:ac3c9abc33ff7e6f061e35c7e67e6eb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to be used on Java side to display objects in tree; this returns just the object's name.  <a href="#ac3c9abc33ff7e6f061e35c7e67e6eb14">More...</a><br/></td></tr>
<tr class="separator:ac3c9abc33ff7e6f061e35c7e67e6eb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf9602cb1075775f01243618e8cf57b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1PropertySet.html">PropertySet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#accf9602cb1075775f01243618e8cf57b">getPropertySet</a> ()</td></tr>
<tr class="memdesc:accf9602cb1075775f01243618e8cf57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">OBSOLETE: Get a reference to the <a class="el" href="classOpenSim_1_1PropertySet.html" title="A property set is simply a set of properties. ">PropertySet</a> maintained by the <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.  <a href="#accf9602cb1075775f01243618e8cf57b">More...</a><br/></td></tr>
<tr class="separator:accf9602cb1075775f01243618e8cf57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08df031ee6f34e151108dbb94be924f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOpenSim_1_1PropertySet.html">PropertySet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a08df031ee6f34e151108dbb94be924f6">getPropertySet</a> () const </td></tr>
<tr class="separator:a08df031ee6f34e151108dbb94be924f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37944898e801cba2bf6f772272df2649"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a37944898e801cba2bf6f772272df2649">getClassName</a> ()</td></tr>
<tr class="memdesc:a37944898e801cba2bf6f772272df2649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this class as a string; i.e., "Object".  <a href="#a37944898e801cba2bf6f772272df2649">More...</a><br/></td></tr>
<tr class="separator:a37944898e801cba2bf6f772272df2649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc42e7d52c371b14898ce7e13e55700c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#adc42e7d52c371b14898ce7e13e55700c">setSerializeAllDefaults</a> (bool shouldSerializeDefaults)</td></tr>
<tr class="memdesc:adc42e7d52c371b14898ce7e13e55700c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function to control whether all registered objects and their properties are written to the defaults section of output files rather than only those values for which the default was explicitly overwritten when read in from an input file or set programmatically.  <a href="#adc42e7d52c371b14898ce7e13e55700c">More...</a><br/></td></tr>
<tr class="separator:adc42e7d52c371b14898ce7e13e55700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533e0a9420d312a73cb9a5d8efd17081"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a533e0a9420d312a73cb9a5d8efd17081">getSerializeAllDefaults</a> ()</td></tr>
<tr class="memdesc:a533e0a9420d312a73cb9a5d8efd17081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report the value of the "serialize all defaults" flag.  <a href="#a533e0a9420d312a73cb9a5d8efd17081">More...</a><br/></td></tr>
<tr class="separator:a533e0a9420d312a73cb9a5d8efd17081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9debf9775f9e8c0b517654cb19669518"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a9debf9775f9e8c0b517654cb19669518">isKindOf</a> (const char *type)</td></tr>
<tr class="memdesc:a9debf9775f9e8c0b517654cb19669518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the passed-in string is "Object"; each Object-derived class defines a method of this name for its own class name.  <a href="#a9debf9775f9e8c0b517654cb19669518">More...</a><br/></td></tr>
<tr class="separator:a9debf9775f9e8c0b517654cb19669518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f10ccc4bc8ab3b0b4e68d3ab75f892"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a46f10ccc4bc8ab3b0b4e68d3ab75f892">setDebugLevel</a> (int newLevel)</td></tr>
<tr class="memdesc:a46f10ccc4bc8ab3b0b4e68d3ab75f892"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> the debug level to get verbose output.  <a href="#a46f10ccc4bc8ab3b0b4e68d3ab75f892">More...</a><br/></td></tr>
<tr class="separator:a46f10ccc4bc8ab3b0b4e68d3ab75f892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96486fa12910478db9b65384546d9e97"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a96486fa12910478db9b65384546d9e97">getDebugLevel</a> ()</td></tr>
<tr class="memdesc:a96486fa12910478db9b65384546d9e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current setting of debug level.  <a href="#a96486fa12910478db9b65384546d9e97">More...</a><br/></td></tr>
<tr class="separator:a96486fa12910478db9b65384546d9e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72643bf97b601311912f678bb3770abe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOpenSim_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a72643bf97b601311912f678bb3770abe">SafeCopy</a> (const <a class="el" href="classOpenSim_1_1Object.html">Object</a> *aObject)</td></tr>
<tr class="memdesc:a72643bf97b601311912f678bb3770abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the <a class="el" href="classOpenSim_1_1Object.html#af221c900c5447df9928f1786469ef1b8" title="Create a new heap-allocated copy of the concrete object to which this Object refers. ">clone()</a> method to duplicate the given object unless the pointer is null in which case null is returned.  <a href="#a72643bf97b601311912f678bb3770abe">More...</a><br/></td></tr>
<tr class="separator:a72643bf97b601311912f678bb3770abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6f962db2c026cce6176ed5017e805c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a0a6f962db2c026cce6176ed5017e805c">RegisterType</a> (const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;defaultObject)</td></tr>
<tr class="memdesc:a0a6f962db2c026cce6176ed5017e805c"><td class="mdescLeft">&#160;</td><td class="mdescRight">OBSOLETE alternate name for <a class="el" href="classOpenSim_1_1Object.html#ace1fe7d9f4d7509b5d9e74fbe757b72d" title="Register an instance of a class; if the class is already registered it will be replaced. ">registerType()</a>.  <a href="#a0a6f962db2c026cce6176ed5017e805c">More...</a><br/></td></tr>
<tr class="separator:a0a6f962db2c026cce6176ed5017e805c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7d3f95ec3dcec17bd5fc17de4b3062"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Object.html#a2b7d3f95ec3dcec17bd5fc17de4b3062">RenameType</a> (const std::string &amp;oldName, const std::string &amp;newName)</td></tr>
<tr class="memdesc:a2b7d3f95ec3dcec17bd5fc17de4b3062"><td class="mdescLeft">&#160;</td><td class="mdescRight">OBSOLETE alternate name for <a class="el" href="classOpenSim_1_1Object.html#ad4f89d1f8a5d4b85dba51df9b207183b" title="Support versioning by associating the current Object type with an old name. ">renameType()</a>.  <a href="#a2b7d3f95ec3dcec17bd5fc17de4b3062">More...</a><br/></td></tr>
<tr class="separator:a2b7d3f95ec3dcec17bd5fc17de4b3062"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the base class for all OpenSim objects that are serializable (meaning they can be written to and read back from files). </p>
<p>In particular, all <a class="el" href="classOpenSim_1_1ModelComponent.html" title="This defines the abstract ModelComponent class, which is used to add computational components to the ...">ModelComponent</a> objects derive from Object. It provides a common base class from which to derive serializable objects and also some basic functionality, such as writing to files in XML format, managing properties, and the equality, less than, and output operators.</p>
<p>An Object maintains a table of "properties" that know how to read themselves from XML and write themselves to XML. The available <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> types are</p>
<ol type="1">
<li>Primitive data types (int, bool, double, std::string, ...)</li>
<li>Properties that contain other Objects,</li>
<li>Properties containing lists of either of the previous 2 categories</li>
</ol>
<p>It is important to note that Objects and Properties together form a recursive tree structure that is the representation of an OpenSim <a class="el" href="classOpenSim_1_1Model.html" title="A concrete class that specifies the interface to a musculoskeletal model. ">Model</a>. See the documentation for the <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">OpenSim::Property</a> class for more information.</p>
<h3>Object declaration</h3>
<p>The declaration of every class derived from Object <em>must</em> have its first line (that is, immediately after the "{" in the class declaration) one of four standard "boilerplate" macros: </p>
<div class="fragment"><div class="line"><a class="code" href="classOpenSim_1_1Object.html#a13075f96c92f1a0f18b791adf0fa255b">OpenSim_DECLARE_CONCRETE_OBJECT</a>  (ClassName, SuperclassName);</div>
<div class="line"><a class="code" href="classOpenSim_1_1Object.html#a04a016239bdc0a855927f706eca78876">OpenSim_DECLARE_CONCRETE_OBJECT_T</a>(ClassName, T, SuperclassName);</div>
<div class="line"><a class="code" href="classOpenSim_1_1Object.html#ab75c37552f6feacddf9fc1d9a7c08cbe">OpenSim_DECLARE_ABSTRACT_OBJECT</a>  (ClassName, SuperclassName);</div>
<div class="line"><a class="code" href="classOpenSim_1_1Object.html#af7bc131913e859c757561270bb3adb86">OpenSim_DECLARE_ABSTRACT_OBJECT_T</a>(ClassName, T, SuperclassName);</div>
</div><!-- fragment --><p> ("Superclass" means the immediate class from which the class derives; that terminology is borrowed from Java. It is often called the "Parent" class but we'll use "Super" which is more precise.) The "_T" variants of the above macros are used for objects that are templatized, like <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a>&lt;T&gt;.</p>
<p>These macros provide a standardized set of declarations for every object, including </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> ClassName      Self;                <span class="comment">// for all classes</span></div>
<div class="line"><span class="keyword">typedef</span> SuperclassName Super;               <span class="comment">// for all classes</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string&amp; <a class="code" href="classOpenSim_1_1Object.html#a37944898e801cba2bf6f772272df2649">getClassName</a>();   <span class="comment">// for all classes</span></div>
<div class="line"><span class="keyword">const</span> std::string&amp; <a class="code" href="classOpenSim_1_1Object.html#a56f3462342f51392a34cb4f0787ae2b7">getConcreteClassName</a>();  <span class="comment">// for concrete classes only</span></div>
<div class="line">ClassName* <a class="code" href="classOpenSim_1_1Object.html#af221c900c5447df9928f1786469ef1b8">clone</a>() <span class="keyword">const</span>;                   <span class="comment">// see below</span></div>
</div><!-- fragment --><p> <a class="el" href="classOpenSim_1_1Object.html#a37944898e801cba2bf6f772272df2649" title="Return the name of this class as a string; i.e., &quot;Object&quot;. ">getClassName()</a> is a static method that returns the name of the Object-derived class for which it is invoked. For example, <a class="el" href="classOpenSim_1_1Object.html#a37944898e801cba2bf6f772272df2649" title="Return the name of this class as a string; i.e., &quot;Object&quot;. ">ModelComponent::getClassName()</a> returns "ModelComponent". In contrast, <a class="el" href="classOpenSim_1_1Object.html#a56f3462342f51392a34cb4f0787ae2b7" title="Returns the class name of the concrete Object-derived class of the actual object referenced by this O...">getConcreteClassName()</a> is a pure virtual method of Object that returns the class name of the actual concrete object being referenced through the abstract base class. This method is implemented only in concrete classes.</p>
<p>Note that <a class="el" href="classOpenSim_1_1Object.html#a37944898e801cba2bf6f772272df2649" title="Return the name of this class as a string; i.e., &quot;Object&quot;. ">getClassName()</a> and <a class="el" href="classOpenSim_1_1Object.html#a56f3462342f51392a34cb4f0787ae2b7" title="Returns the class name of the concrete Object-derived class of the actual object referenced by this O...">getConcreteClassName()</a> will return the same string only if the referenced class is concrete. For example, </p>
<div class="fragment"><div class="line">Function* funcp = <span class="keyword">new</span> LinearFunction(...);</div>
<div class="line">std::cout &lt;&lt; funcp-&gt;getClassName();          <span class="comment">// output: &quot;Function&quot;</span></div>
<div class="line">std::cout &lt;&lt; funcp-&gt;getConcreteClassName();  <span class="comment">// output: &quot;LinearFunction&quot;</span></div>
</div><!-- fragment --><p>For concrete objects, the class name is used as the "object type tag", the tag string that will appear in XML files. Also, when a <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a>&lt;T&gt; has no name (allowed for properties that contain just a single object) the object class name T (which may be abstract like <a class="el" href="classOpenSim_1_1Function.html">Function</a> or <a class="el" href="classOpenSim_1_1ModelComponent.html" title="This defines the abstract ModelComponent class, which is used to add computational components to the ...">ModelComponent</a>) is used to select the property. See <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">OpenSim::Property</a> for more information.</p>
<p>The standard <a class="el" href="classOpenSim_1_1Object.html#af221c900c5447df9928f1786469ef1b8" title="Create a new heap-allocated copy of the concrete object to which this Object refers. ">clone()</a> method produces a duplicate of a concrete object and thus is implemented only for concrete classes. However, the return type must always match the type of the invoking object (this is called a "covariant type" and does not change the method's identity). It is therefore redeclared even in abstract classes, but remains pure virtual in those cases. That means if you invoke <a class="el" href="classOpenSim_1_1Object.html#af221c900c5447df9928f1786469ef1b8" title="Create a new heap-allocated copy of the concrete object to which this Object refers. ">Function::clone()</a> you'll get back a Function* rather than an Object*; this avoids many unnecessary invocations of the awkward and expensive dynamic_cast operator.</p>
<h3>Object registration and renaming</h3>
<p>An Object type needs to be "registered" by calling <a class="el" href="classOpenSim_1_1Object.html#ace1fe7d9f4d7509b5d9e74fbe757b72d" title="Register an instance of a class; if the class is already registered it will be replaced. ">Object::registerType()</a> with an instance of a concrete object so that the serialization infrastructure knows what kind of Object to create when it encounters a specific XML tag. This associates the concrete object's class name (object type tag) with a default instance of that object. The registration process is normally done during dynamic library (DLL) loading, that is, as part of the static initializer execution that occurs before program execution.</p>
<p>For backwards compatibility, we support a renaming mechanism in which now-deprecated class names can be mapped to their current equivalents. This is done via a string-to-string table mapping the old names to the new ones; only the current names appear in the registered objects table. Specification of these aliases is done immediately after registration in the DLL static initializer.</p>
<h3>Defaults mechanism</h3>
<p>When an Object is registered (either programmatically, or overridden in the defaults section of a document), a copy of it is maintained in a dictionary as a "default" object of its class. When new instances of this class are requested, the contents of the default object are used to populate the new instance before deserialization. This allows for specifying default values that will be commonly used in one place in the XML file rather than with each object which leads to smaller files that are easier to read. <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> values that obtain their values from the defaults and are not subsequently overridden are marked as being default values, allowing us to avoid writing them back out when serializing.</p>
<dl class="section author"><dt>Author</dt><dd>Frank C. Anderson, Ayman Habib, Ajay Seth, Michael Sherman </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">OpenSim::Property</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5dc026c632531b193236dfaa65962d40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual OpenSim::Object::~Object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor for cleanup. </p>

</div>
</div>
<a class="anchor" id="a620026774a4b0d36d93ed12a9451b356"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenSim::Object::Object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor is only for use by constructors of derived types. </p>
<p>Initializes all base class data members to innocuous values. </p>

</div>
</div>
<a class="anchor" id="af1557e960a306925e8e809123f81a331"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenSim::Object::Object </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aUpdateFromXMLNode</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a file, to be called from other constructors that take a file as input. </p>

</div>
</div>
<a class="anchor" id="a88fad2c70cc33674ede31a20a29610fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenSim::Object::Object </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor is invoked automatically by derived classes with default copy constructors; otherwise it must be invoked explicitly. </p>

</div>
</div>
<a class="anchor" id="af8ecc144d30a872d28ab63d82245da9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenSim::Object::Object </td>
          <td>(</td>
          <td class="paramtype">SimTK::Xml::Element &amp;&#160;</td>
          <td class="paramname"><em>aElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the base class portion of an Object from a given Xml element that describes this <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>. </p>
<p>Assumes latest XML file format; there is no provision for version numbering. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad5046920687929fbc0c0ec17681c146d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PropertyIndex OpenSim::Object::addListProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define a new list-valued property of known type T, with the given <em>name</em>, associated <em>comment</em>, minimum (==0) and maximum (&gt;0) allowable list lengths, and a zero-length initial value. </p>
<p>The property must have a name (the empty string is not acceptable), and that name must be unique within this Object's property table. </p>
<dl class="section return"><dt>Returns</dt><dd>The PropertyIndex of this property in the proprty table for this object. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classOpenSim_1_1Object.html#af24322b3b4552de29ed0589a03ba7ad5" title="Define a new single-value property of known type T, with the given name, associated comment...">addProperty()</a>, <a class="el" href="classOpenSim_1_1Object.html#ae33cd5e9f8e0b563ac29f7cf2565d5fc" title="Add an optional property, meaning it can contain either no value or a single value. ">addOptionalProperty()</a> </dd></dl>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a0685f52599efbdd68462babddd4859e4">OpenSim::AbstractProperty::setAllowableListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#aac1cfb86a10115441ef84be3148c0c7d">OpenSim::AbstractProperty::setComment()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e09382ab2bb833eba12c081f35b5a2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PropertyIndex OpenSim::Object::addListProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define a new list-valued property as above, but assigning an initial value via some templatized container class that supports size() and indexing. </p>
<p>Here the minimum size may be greater than zero, provided that the initial value has at least that many element (and no more than the allowed maximum). </p>
<dl class="section return"><dt>Returns</dt><dd>The PropertyIndex of this property in the proprty table for this object. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classOpenSim_1_1Object.html#af24322b3b4552de29ed0589a03ba7ad5" title="Define a new single-value property of known type T, with the given name, associated comment...">addProperty()</a>, <a class="el" href="classOpenSim_1_1Object.html#ae33cd5e9f8e0b563ac29f7cf2565d5fc" title="Add an optional property, meaning it can contain either no value or a single value. ">addOptionalProperty()</a> </dd></dl>

<p>References <a class="el" href="classOpenSim_1_1Property.html#a8cebe3dfc74cb4f1d5158a4feb449e05">OpenSim::Property&lt; T &gt;::appendValue()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a0685f52599efbdd68462babddd4859e4">OpenSim::AbstractProperty::setAllowableListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#aac1cfb86a10115441ef84be3148c0c7d">OpenSim::AbstractProperty::setComment()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

</div>
</div>
<a class="anchor" id="ae33cd5e9f8e0b563ac29f7cf2565d5fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PropertyIndex OpenSim::Object::addOptionalProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an optional property, meaning it can contain either no value or a single value. </p>
<p>Here no initial value is provided. The property must have a name (the empty string is not acceptable), and that name must be unique within this Object's property table. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the new <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> object stored in this object's property table. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classOpenSim_1_1Object.html#af24322b3b4552de29ed0589a03ba7ad5" title="Define a new single-value property of known type T, with the given name, associated comment...">addProperty()</a>, <a class="el" href="classOpenSim_1_1Object.html#ad5046920687929fbc0c0ec17681c146d" title="Define a new list-valued property of known type T, with the given name, associated comment...">addListProperty()</a> </dd></dl>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a0685f52599efbdd68462babddd4859e4">OpenSim::AbstractProperty::setAllowableListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#aac1cfb86a10115441ef84be3148c0c7d">OpenSim::AbstractProperty::setComment()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

</div>
</div>
<a class="anchor" id="affef953ecb6526d5de51f8d045229d79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PropertyIndex OpenSim::Object::addOptionalProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an optional property, meaning it can contain either no value or a single value. </p>
<p>Here an initial value is provided. The property must have a name (the empty string is not acceptable), and that name must be unique within this Object's property table. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the new <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> object stored in this object's property table. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classOpenSim_1_1Object.html#af24322b3b4552de29ed0589a03ba7ad5" title="Define a new single-value property of known type T, with the given name, associated comment...">addProperty()</a>, <a class="el" href="classOpenSim_1_1Object.html#ad5046920687929fbc0c0ec17681c146d" title="Define a new list-valued property of known type T, with the given name, associated comment...">addListProperty()</a> </dd></dl>

<p>References <a class="el" href="classOpenSim_1_1Property.html#a8cebe3dfc74cb4f1d5158a4feb449e05">OpenSim::Property&lt; T &gt;::appendValue()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a0685f52599efbdd68462babddd4859e4">OpenSim::AbstractProperty::setAllowableListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#aac1cfb86a10115441ef84be3148c0c7d">OpenSim::AbstractProperty::setComment()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

</div>
</div>
<a class="anchor" id="af24322b3b4552de29ed0589a03ba7ad5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PropertyIndex OpenSim::Object::addProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define a new single-value property of known type T, with the given <em>name</em>, associated <em>comment</em>, and initial <em>value</em>. </p>
<p>The name must be unique within this Object's property table.</p>
<p>If T is an object type (i.e., derived from Object), it is permissible for the property to be unnamed; pass an empty string for <em>name</em>. You will then be able to select the property using the object class name (that is, T::getClassName()) as though it were the property's name. An Object can thus only have one unnamed property of any particular object type.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the new <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> object stored in this object's property table. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classOpenSim_1_1Object.html#ae33cd5e9f8e0b563ac29f7cf2565d5fc" title="Add an optional property, meaning it can contain either no value or a single value. ">addOptionalProperty()</a>, <a class="el" href="classOpenSim_1_1Object.html#ad5046920687929fbc0c0ec17681c146d" title="Define a new list-valued property of known type T, with the given name, associated comment...">addListProperty()</a> </dd></dl>

<p>References <a class="el" href="classOpenSim_1_1Property.html#a8cebe3dfc74cb4f1d5158a4feb449e05">OpenSim::Property&lt; T &gt;::appendValue()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#aac1cfb86a10115441ef84be3148c0c7d">OpenSim::AbstractProperty::setComment()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

</div>
</div>
<a class="anchor" id="a5291e688292cba7a488b077e6dc64938"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Object::clearObjectIsUpToDateWithProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For testing or debugging purposes, manually clear the "object is up to 
date with respect to properties" flag. </p>
<p>This is normally done automatically when a property is modified. Setting the flag is always done manually, however, see <a class="el" href="classOpenSim_1_1Object.html#a6aff140025aa58def7bad8810a6c4652" title="When an object is initialized using the current values of its properties, it can set a flag indicatin...">setObjectIsUpToDateWithProperties()</a>. </p>

</div>
</div>
<a class="anchor" id="af221c900c5447df9928f1786469ef1b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOpenSim_1_1Object.html">Object</a>* OpenSim::Object::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new heap-allocated copy of the concrete object to which this Object refers. </p>
<p>It is up to the caller to delete the returned object when no longer needed. Every concrete object deriving from Object implements this pure virtual method automatically, via the declaration macro it invokes (e.g., <a class="el" href="classOpenSim_1_1Object.html#a13075f96c92f1a0f18b791adf0fa255b" title="Macro to be included as the first line of the class declaration for any non-templatized, concrete class that derives from OpenSim::Object. ">OpenSim_DECLARE_CONCRETE_OBJECT()</a>). Note that the concrete class overrides modify the return type to be a pointer to the <em>concrete</em> object; that still overrides the base class method because the return type is covariant with (that is, derives from) Object. </p>

<p>Referenced by <a class="el" href="classOpenSim_1_1ControlLinear.html#a6e60e8c7c74fdc95e0b03714de84a5c5">OpenSim::ControlLinear::insertNewMaxNode()</a>, <a class="el" href="classOpenSim_1_1ControlLinear.html#a8cf0d40fda140a7b61cd5c74d920b04c">OpenSim::ControlLinear::insertNewMinNode()</a>, <a class="el" href="classOpenSim_1_1ControlLinear.html#aad86d7559705953f6bbbe0a8e7e3e7a8">OpenSim::ControlLinear::insertNewValueNode()</a>, <a class="el" href="classOpenSim_1_1Object.html#a72643bf97b601311912f678bb3770abe">SafeCopy()</a>, <a class="el" href="classOpenSim_1_1CoordinateCouplerConstraint.html#ab66481db2f5f645c2cb388c602e29c4c">OpenSim::CoordinateCouplerConstraint::setFunction()</a>, <a class="el" href="classOpenSim_1_1PropertyObj.html#a30f5af86a9b39af3834e371e951a44b9">OpenSim::PropertyObj::setValueAsObject()</a>, and <a class="el" href="classOpenSim_1_1PropertyObjPtr.html#a5112192d9f548faf0ab95f63ba4aa128">OpenSim::PropertyObjPtr&lt; OpenSim::Function &gt;::setValueAsObject()</a>.</p>

</div>
</div>
<a class="anchor" id="aa0e26741bc3518688164242c4b880c71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string OpenSim::Object::dump </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dumpName</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>dump the XML representation of this Object into an std::string and return it. </p>
<p>Mainly intended for debugging and for use by the XML browser in the GUI. </p>

</div>
</div>
<a class="anchor" id="a33466c9415fae20658e0cb03919c9ea3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; OpenSim::Object::getAuthors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get Authors of this <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>. </p>

</div>
</div>
<a class="anchor" id="a37944898e801cba2bf6f772272df2649"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; OpenSim::Object::getClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the name of this class as a string; i.e., "Object". </p>
<p>See <a class="el" href="classOpenSim_1_1Object.html#a56f3462342f51392a34cb4f0787ae2b7" title="Returns the class name of the concrete Object-derived class of the actual object referenced by this O...">getConcreteClassName()</a> if you want the class name of the underlying concrete object instead. Note that this method is automatically supplied for every class declaration that derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> via the standard macro provided for that purpose. See introductory text for this <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> class for more information. </p>

</div>
</div>
<a class="anchor" id="a56f3462342f51392a34cb4f0787ae2b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; OpenSim::Object::getConcreteClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the class name of the concrete Object-derived class of the actual object referenced by this Object, as a string. </p>
<p>This is the string that is used as the tag for this concrete object in an XML file. Every concrete class derived from Object automatically overrides this method via the declaration macro it uses. See <a class="el" href="classOpenSim_1_1Object.html#a37944898e801cba2bf6f772272df2649" title="Return the name of this class as a string; i.e., &quot;Object&quot;. ">getClassName()</a> to get the class name of the referencing (possibly abstract) class rather than the concrete object. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classOpenSim_1_1Object.html#a37944898e801cba2bf6f772272df2649" title="Return the name of this class as a string; i.e., &quot;Object&quot;. ">getClassName()</a> </dd></dl>

<p>Referenced by <a class="el" href="classOpenSim_1_1PropertyObjArray.html#a842491234c9229e06e606970f239ba16">OpenSim::PropertyObjArray&lt; Control &gt;::appendValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a96486fa12910478db9b65384546d9e97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenSim::Object::getDebugLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current setting of debug level. </p>

</div>
</div>
<a class="anchor" id="afa003166ace3f14af022b6650fc6fbd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classOpenSim_1_1Object.html">Object</a>* OpenSim::Object::getDefaultInstanceOfType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>concreteClassName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the default instance of the registered (concrete) Object whose class name is given, or NULL if the type is not registered. </p>
<p>Note that this refers to the default Object instance that is stored with the Object class; do not delete it! If you want a copy of this object instead, use <a class="el" href="classOpenSim_1_1Object.html#afd44aecebc85d2f98ff3adf443e284d0" title="Create a new instance of the concrete Object type whose class name is given as concreteClassName. ">newInstanceOfType()</a>. The given <em>concreteClassName</em> will be mapped through the renamed type table if necessary but the returned object will always have the new type name, which may differ from the supplied one. Note that renaming is applied first, prior to looking up the name in the registered objects table. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classOpenSim_1_1Object.html#ace1fe7d9f4d7509b5d9e74fbe757b72d" title="Register an instance of a class; if the class is already registered it will be replaced. ">registerType()</a>, <a class="el" href="classOpenSim_1_1Object.html#ad4f89d1f8a5d4b85dba51df9b207183b" title="Support versioning by associating the current Object type with an old name. ">renameType()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a95c82687e6065eaaded78637d6b962b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; OpenSim::Object::getDescription </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get description, a one-liner summary. </p>

</div>
</div>
<a class="anchor" id="ad198104a9d49d467c58488a6964d6730"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classOpenSim_1_1VisibleObject.html">VisibleObject</a>* OpenSim::Object::getDisplayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods to support making the object displayable in the GUI or Visualizer Implemented only in few objects. </p>
<p>Get const pointer to <a class="el" href="classOpenSim_1_1VisibleObject.html" title="Class VisibleObject is intended to be used as the base class for all Visible objects that subclass Ob...">VisibleObject</a> that contains geometry </p>

<p>Reimplemented in <a class="el" href="classOpenSim_1_1PathSpring.html#aadf6c3f259f22869e9c4d364a4c75f79">OpenSim::PathSpring</a>, <a class="el" href="classOpenSim_1_1GeometryPath.html#a0d0b1209fe29bd6663301b3d5720b914">OpenSim::GeometryPath</a>, <a class="el" href="classOpenSim_1_1ExpressionBasedPointToPointForce.html#a73be359af2c36643d430b196097c1892">OpenSim::ExpressionBasedPointToPointForce</a>, <a class="el" href="classOpenSim_1_1ContactGeometry.html#a4a6f8ac675f41af8c8a4c87ac995e3da">OpenSim::ContactGeometry</a>, <a class="el" href="classOpenSim_1_1PathPoint.html#ae48b245b2dffa69c2f862c29d6c31f75">OpenSim::PathPoint</a>, <a class="el" href="classOpenSim_1_1Body.html#a0c950522622c4373719956eefe31fe78">OpenSim::Body</a>, <a class="el" href="classOpenSim_1_1Marker.html#a1ea5eeed553c04a953a3840319b51146">OpenSim::Marker</a>, <a class="el" href="classOpenSim_1_1PathActuator.html#a9954d7c8f2eca8dbc40c4579e7569c4c">OpenSim::PathActuator</a>, <a class="el" href="classOpenSim_1_1Ligament.html#ad0d5b3627a42e5dd9ab2dfe54e52e1d2">OpenSim::Ligament</a>, and <a class="el" href="classOpenSim_1_1PointToPointSpring.html#a7cf0319ce3235edbcb713c0547a79c2d">OpenSim::PointToPointSpring</a>.</p>

</div>
</div>
<a class="anchor" id="a00afa73fcae409e8b8c993d3e977149f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a>* OpenSim::Object::getDocument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const pointer to the document (if any) associated with this object. </p>

</div>
</div>
<a class="anchor" id="ad54c991bb056d6cafe4c26d670c9c891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string OpenSim::Object::getDocumentFileName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there is a document associated with this object then return the file name maintained by the document. </p>
<p>Otherwise return an empty string. </p>

</div>
</div>
<a class="anchor" id="a10d8a9b32fa174430a354c3508345bc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenSim::Object::getInlined </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inlined means an in-memory <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> that is not associated with an <a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a>. </p>

</div>
</div>
<a class="anchor" id="a5915b8c1d384df8ac19fd11a1fb21ccd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; OpenSim::Object::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of this <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>. </p>

<p>Referenced by <a class="el" href="classOpenSim_1_1ProbeReporter.html#afec55d83071ec14478ed470642b64412">OpenSim::ProbeReporter::disableIntegrationOnlyProbes()</a>.</p>

</div>
</div>
<a class="anchor" id="aa298781dd5a5b3c892662ef73172f0bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OpenSim::Object::getNumProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine how many properties are stored with this Object. </p>
<p>These are numbered 0..n-1 in the order they were created. </p>

</div>
</div>
<a class="anchor" id="ae569867dea47d552436ca887a580dd3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp; OpenSim::Object::getProperty </td>
          <td>(</td>
          <td class="paramtype">const PropertyIndex &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get property of known type <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a>&lt;T&gt; as a const reference; the property must be present and have the right type. </p>
<p>This is primarily used by the <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> declaration macros for fast access to properties. </p>

</div>
</div>
<a class="anchor" id="a3135199b9122677080358606b672d8df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&amp; OpenSim::Object::getPropertyByIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propertyIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const reference to a property by its index number, returned as an <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a>. </p>

</div>
</div>
<a class="anchor" id="a1a65abcee1fee7ef6a261f99c45e46d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&amp; OpenSim::Object::getPropertyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const reference to a property by its name, returned as an <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a>. </p>
<p>An exception is thrown if no property by this name is present in this Object. </p>

</div>
</div>
<a class="anchor" id="ae2a709cf81656cfd97bf37237bd03082"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PropertyIndex OpenSim::Object::getPropertyIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up a property by name and return its PropertyIndex if it is found. </p>
<p>If no property of that name is present, the returned index will be invalid; check with isValid(). </p>

</div>
</div>
<a class="anchor" id="a8c14b84c3759aa0298bc772f06e9bbc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PropertyIndex OpenSim::Object::getPropertyIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up an unnamed property by the type of object it contains, and return its PropertyIndex if it is found. </p>
<p>If no unnamed property of that type is present, the returned index will be invalid; check with isValid(). </p>

</div>
</div>
<a class="anchor" id="accf9602cb1075775f01243618e8cf57b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1PropertySet.html">PropertySet</a>&amp; OpenSim::Object::getPropertySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OBSOLETE: Get a reference to the <a class="el" href="classOpenSim_1_1PropertySet.html" title="A property set is simply a set of properties. ">PropertySet</a> maintained by the <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>. </p>

<p>Referenced by <a class="el" href="classOpenSim_1_1CMC__TaskSet.html#a39aebdf54a398dbf63554ebcf3eafcff">OpenSim::CMC_TaskSet::CMC_TaskSet()</a>.</p>

</div>
</div>
<a class="anchor" id="a08df031ee6f34e151108dbb94be924f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOpenSim_1_1PropertySet.html">PropertySet</a>&amp; OpenSim::Object::getPropertySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e03d1cd0bda7673fc8d697a0114fc96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; OpenSim::Object::getReferences </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get references or publications to cite if using this object. </p>

</div>
</div>
<a class="anchor" id="a34f0039fba61c2fef84ba6bf8c07de6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Object::getRegisteredObjectsOfGivenType </td>
          <td>(</td>
          <td class="paramtype">ArrayPtrs&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rArray</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an array of pointers to the default instances of all registered (concrete) Object types that derive from a given Object-derived type that does not have to be concrete. </p>
<p>This is useful, for example, to find all Joints, Constraints, ModelComponents, Analyses, etc. </p>

</div>
</div>
<a class="anchor" id="a0296f61a06c319786a46d29743135d74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Object::getRegisteredTypenames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>typeNames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve all the typenames registered so far. </p>
<p>This is done by traversing the registered objects map, so only concrete classes that have registered instances are returned; renamed types will not appear unless they were separately registered. (Note that even if one registered type has been renamed to another, both will appear in the returned list.) The result returned in <em>typeNames</em> should not be cached while more shared libraries or plugins are loaded, because more types may be registered as a result. Instead the list should be reconstructed whenever in doubt. </p>

</div>
</div>
<a class="anchor" id="a533e0a9420d312a73cb9a5d8efd17081"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenSim::Object::getSerializeAllDefaults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report the value of the "serialize all defaults" flag. </p>

</div>
</div>
<a class="anchor" id="a0e325f974b4640ba3a61658d83a4e5bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenSim::Object::hasProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this Object has a property of any type with the given <em>name</em>, which must not be empty. </p>

</div>
</div>
<a class="anchor" id="ab6af5b2dc8e345c2a99a50f75ce12275"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool OpenSim::Object::hasProperty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this Object contains an unnamed, one-object property that contains objects of the given template type T. </p>
<p>The type must match exactly the type used when this property was created with <a class="el" href="classOpenSim_1_1Object.html#af24322b3b4552de29ed0589a03ba7ad5" title="Define a new single-value property of known type T, with the given name, associated comment...">addProperty&lt;T&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a126f1d87df28a081c7b1c99bb477cb3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OpenSim::Object::isA </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default implementation returns true only if the supplied string is "Object"; each Object-derived class overrides this to match its own class name. </p>

</div>
</div>
<a class="anchor" id="a6690bb504728e0ba5d675178616005c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenSim::Object::isEqualTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>aObject</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator wrapper for use from languages not supporting operator overloading. </p>

</div>
</div>
<a class="anchor" id="a9debf9775f9e8c0b517654cb19669518"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenSim::Object::isKindOf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the passed-in string is "Object"; each Object-derived class defines a method of this name for its own class name. </p>

</div>
</div>
<a class="anchor" id="a77a7df6eb433b4e130ce7aa63b8d3d7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OpenSim::Object::isObjectTypeDerivedFrom </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>concreteClassName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the given concrete object type represents a subclass of the template object type T, and thus could be referenced with a T*. </p>
<p>The object type to be tested is given by its class name as a string. For this to work the name must represent an already-registered object type. If necessary <em>concreteClassName</em> will be mapped through the renamed type table, so we'll return true if the class it maps to satisfies the condition. Note that renaming is applied first, prior to looking up the name in the registered objects table. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classOpenSim_1_1Object.html#ace1fe7d9f4d7509b5d9e74fbe757b72d" title="Register an instance of a class; if the class is already registered it will be replaced. ">registerType()</a>, <a class="el" href="classOpenSim_1_1Object.html#ad4f89d1f8a5d4b85dba51df9b207183b" title="Support versioning by associating the current Object type with an old name. ">renameType()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8e4e64da3072679681702cdb786c41cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenSim::Object::isObjectUpToDateWithProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if no property's value has changed since the last time <a class="el" href="classOpenSim_1_1Object.html#a6aff140025aa58def7bad8810a6c4652" title="When an object is initialized using the current values of its properties, it can set a flag indicatin...">setObjectIsUpToDateWithProperties()</a> was called. </p>

</div>
</div>
<a class="anchor" id="ab7d860a7849ddbb27885673dbf5dbf76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOpenSim_1_1Object.html">Object</a>* OpenSim::Object::makeObjectFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an OpenSim object whose type is based on the tag at the root node of the XML file passed in. </p>
<p>This is useful since the constructor of Object doesn't have the proper type info. This works by using the defaults table so that Object does not need to know about its derived classes. It uses the defaults table to get an instance. </p>

</div>
</div>
<a class="anchor" id="afd44aecebc85d2f98ff3adf443e284d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOpenSim_1_1Object.html">Object</a>* OpenSim::Object::newInstanceOfType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>concreteClassName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new instance of the concrete Object type whose class name is given as <em>concreteClassName</em>. </p>
<p>The instance is initialized to the default object of corresponding type, possibly after renaming to the current class name. Writes a message to stderr and returns null if the tag isn't registered. </p>

</div>
</div>
<a class="anchor" id="a3fe4c39736b73c4df2f9c68c7a9f74a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OpenSim::Object::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>aObject</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide an ordering for objects so they can be put in sorted containers. </p>

</div>
</div>
<a class="anchor" id="a1296dda9711e0e061fd29b88eacae796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Object.html">Object</a>&amp; OpenSim::Object::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>aObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment copies he base class fields, including the properties. </p>

<p>Referenced by <a class="el" href="classOpenSim_1_1StorageInterface.html#a8576a6d8c3423a1441af1cf4e1c8c0f7">OpenSim::StorageInterface::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a96b3686d0084ddba34a754cf61996b71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OpenSim::Object::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>aObject</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if two objects are equal. </p>
<p>They are equal if all the simple base class members are equal, both objects have the same number of properties and corresponding properties are equal, and if the objects are the same concrete type and the concrete class says they are equal. Concrete object classes must override this if they have any fields to compare, but be sure to invoke the base class operator too. </p>

</div>
</div>
<a class="anchor" id="abb75c7ca31491448197278e589266c48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenSim::Object::print </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write this Object into an XML file of the given name; conventionally the suffix to use is ".osim". </p>
<p>This is useful for writing out a <a class="el" href="classOpenSim_1_1Model.html" title="A concrete class that specifies the interface to a musculoskeletal model. ">Model</a> that has been created programmatically, and also very useful for testing and debugging. </p>

</div>
</div>
<a class="anchor" id="a0586ab0764c0a94ead847bb0ca4c0eb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Object::PrintPropertyInfo </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>classNameDotPropertyName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump formatted property information to a given output stream, useful for creating a "help" facility for registered objects. </p>
<p><a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> name, property name, and property comment are output. Input is a class name and property name. If the property name is the empty string or just "*", then information for all properties in the class is printed. If the class name is empty, information in all properties of all registered classes is printed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream to which info is printed. </td></tr>
    <tr><td class="paramname">classNameDotPropertyName</td><td>A string combining the class name and property name. The two names should be separated by a period (ClassName.PropertyName). If PropertyName is empty or "*", the information for all properties in the class is printed. If ClassName is empty, the information for the properties of all registered classes is printed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaab93bb0a139e5e11f359d61fe1ae3e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Object::PrintPropertyInfo </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>className</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as the other signature but the class name and property name are provided as two separate strings. </p>

</div>
</div>
<a class="anchor" id="abd740e38f08939be0c05b622b2a5f61e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Object::readObjectFromXMLNodeOrFile </td>
          <td>(</td>
          <td class="paramtype">SimTK::Xml::Element &amp;&#160;</td>
          <td class="paramname"><em>objectElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>versionNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We're given an XML element from which we are to populate this Object. </p>
<p>If the element has a <code>file</code> attribute, we'll instead read the Object from that file. Otherwise we'll invoke <a class="el" href="classOpenSim_1_1Object.html#a988abda95a67bb454373a89fe38f2af7" title="Use this method to deserialize an object from a SimTK::Xml::Element. ">updateFromXMLNode()</a> to read the Object directly from the supplied element. Note that a relative file name will be interpreted relative to the current working directory, but that will normally have been set earlier to the directory containing the top-level (root) Object, such as the <a class="el" href="classOpenSim_1_1Model.html" title="A concrete class that specifies the interface to a musculoskeletal model. ">Model</a> file. </p>

</div>
</div>
<a class="anchor" id="ace1fe7d9f4d7509b5d9e74fbe757b72d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Object::registerType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>defaultObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an instance of a class; if the class is already registered it will be replaced. </p>
<p>This is normally called as part of the static intialization of a dynamic library (DLL). The supplied object's concrete class name will be used as a key, and a <em>copy</em> (via <a class="el" href="classOpenSim_1_1Object.html#af221c900c5447df9928f1786469ef1b8" title="Create a new heap-allocated copy of the concrete object to which this Object refers. ">clone()</a>) of the supplied Object is used as the default value for objects of this type when created (typically during the deserialization process when reading an XML file). </p>

</div>
</div>
<a class="anchor" id="a0a6f962db2c026cce6176ed5017e805c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Object::RegisterType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>defaultObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OBSOLETE alternate name for <a class="el" href="classOpenSim_1_1Object.html#ace1fe7d9f4d7509b5d9e74fbe757b72d" title="Register an instance of a class; if the class is already registered it will be replaced. ">registerType()</a>. </p>

</div>
</div>
<a class="anchor" id="ad4f89d1f8a5d4b85dba51df9b207183b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Object::renameType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldTypeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newTypeName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Support versioning by associating the current Object type with an old name. </p>
<p>This is only allowed if <em>newTypeName</em> has already been registered with <a class="el" href="classOpenSim_1_1Object.html#ace1fe7d9f4d7509b5d9e74fbe757b72d" title="Register an instance of a class; if the class is already registered it will be replaced. ">registerType()</a>. Renaming is applied first prior to lookup so can be used both for translating now-obsolete names to their new names and for overriding one registered type with another. </p>

</div>
</div>
<a class="anchor" id="a2b7d3f95ec3dcec17bd5fc17de4b3062"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Object::RenameType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OBSOLETE alternate name for <a class="el" href="classOpenSim_1_1Object.html#ad4f89d1f8a5d4b85dba51df9b207183b" title="Support versioning by associating the current Object type with an old name. ">renameType()</a>. </p>

</div>
</div>
<a class="anchor" id="a72643bf97b601311912f678bb3770abe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOpenSim_1_1Object.html">Object</a>* OpenSim::Object::SafeCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Object.html">Object</a> *&#160;</td>
          <td class="paramname"><em>aObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the <a class="el" href="classOpenSim_1_1Object.html#af221c900c5447df9928f1786469ef1b8" title="Create a new heap-allocated copy of the concrete object to which this Object refers. ">clone()</a> method to duplicate the given object unless the pointer is null in which case null is returned. </p>

<p>References <a class="el" href="classOpenSim_1_1Object.html#af221c900c5447df9928f1786469ef1b8">clone()</a>.</p>

</div>
</div>
<a class="anchor" id="a092550b5528d3d817022c045e4144183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Object::setAllPropertiesUseDefault </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aUseDefault</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5543fa91645f86c336d121cf6da60dfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Object::setAuthors </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>authors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> Authors of this object, call this method in your constructor if needed. </p>

</div>
</div>
<a class="anchor" id="a46f10ccc4bc8ab3b0b4e68d3ab75f892"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Object::setDebugLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> the debug level to get verbose output. </p>
<p>Zero means no debugging. </p>

</div>
</div>
<a class="anchor" id="a736967772e266744409791c21a94dd80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Object::setDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> description, a one-liner summary. </p>

</div>
</div>
<a class="anchor" id="abb6cc3ab175f7fbd32e9bc001d5ba30a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Object::setDocument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a> *&#160;</td>
          <td class="paramname"><em>doc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unconditionally set the <a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a> associated with this object. </p>
<p>Use carefully &ndash; if there was already a document its heap space is lost here. </p>

</div>
</div>
<a class="anchor" id="ab419ca21895e653bffb4fc5b0ac3afa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Object::setInlined </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aInlined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aFileName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark this as inlined or not and optionally provide a file name to associate with the new <a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a> for the non-inline case. </p>
<p>If there was already a document associated with this object it is deleted. </p>

</div>
</div>
<a class="anchor" id="a44921f417260a606255a162bfaa74e85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Object::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> the name of the <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>. </p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Reference__.html#aa072ada1c9f2a1570a9d81d042540b50">OpenSim::Reference_&lt; SimTK::Vec3 &gt;::Reference_()</a>, and <a class="el" href="classOpenSim_1_1Set.html#ab05d7a8d452afac3bc1d997d072a3fff">OpenSim::Set&lt; Control &gt;::renameGroup()</a>.</p>

</div>
</div>
<a class="anchor" id="a6aff140025aa58def7bad8810a6c4652"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Object::setObjectIsUpToDateWithProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When an object is initialized using the current values of its properties, it can set a flag indicating that it is up to date. </p>
<p>This flag is automatically cleared when any property is modified. This allows objects to avoid expensive reinitialization if it is unnecessary (that is, whenever this Object hands out writable access to a property). Note that use of this flag is entirely optional; most Object classes don't have any expensive initialization to worry about.</p>
<p>This flag is cleared automatically but if you want to clear it manually for testing or debugging, see <a class="el" href="classOpenSim_1_1Object.html#a5291e688292cba7a488b077e6dc64938" title="For testing or debugging purposes, manually clear the &quot;object is up to  date with respect to properti...">clearObjectIsUpToDateWithProperties()</a>. </p>

</div>
</div>
<a class="anchor" id="a3cf59c40ec8751e01d736db3383cbe50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Object::setReferences </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>references</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> references or publications to cite if using this object. </p>

</div>
</div>
<a class="anchor" id="adc42e7d52c371b14898ce7e13e55700c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void OpenSim::Object::setSerializeAllDefaults </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldSerializeDefaults</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function to control whether all registered objects and their properties are written to the defaults section of output files rather than only those values for which the default was explicitly overwritten when read in from an input file or set programmatically. </p>

</div>
</div>
<a class="anchor" id="ac3c9abc33ff7e6f061e35c7e67e6eb14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; OpenSim::Object::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to be used on Java side to display objects in tree; this returns just the object's name. </p>

</div>
</div>
<a class="anchor" id="a1d2da63a45b146424737d00c128a8491"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::Object::updateFromXMLDocument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this method only if you're deserializing from a file and the object is at the top level; that is, primarily in constructors that take a file name as input. </p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Set.html#a4dbd7345d1ac611c4773c52e5a6fcc67">OpenSim::Set&lt; Control &gt;::Set()</a>.</p>

</div>
</div>
<a class="anchor" id="a988abda95a67bb454373a89fe38f2af7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OpenSim::Object::updateFromXMLNode </td>
          <td>(</td>
          <td class="paramtype">SimTK::Xml::Element &amp;&#160;</td>
          <td class="paramname"><em>objectElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>versionNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use this method to deserialize an object from a SimTK::Xml::Element. </p>
<p>The element is assumed to be in the format consistent with the passed-in <em>versionNumber</em>. If there is a file attribute in <em>objectElement</em> it will be ignored; if you want it processed you should call <a class="el" href="classOpenSim_1_1Object.html#abd740e38f08939be0c05b622b2a5f61e" title="We&#39;re given an XML element from which we are to populate this Object. ">readObjectFromXMLNodeOrFile()</a> instead. </p>

<p>Reimplemented in <a class="el" href="classOpenSim_1_1Model.html#a0213388924ba0b6b1e1b5bc43915de42">OpenSim::Model</a>, <a class="el" href="classOpenSim_1_1AbstractTool.html#a8b68ee7a64e8f07d5f08b35f08187b90">OpenSim::AbstractTool</a>, <a class="el" href="classOpenSim_1_1VisibleObject.html#a957c72a93abf1540d51e90fce881a354">OpenSim::VisibleObject</a>, <a class="el" href="classOpenSim_1_1CMC__Task.html#a4b70320e9e880dae26c9dde2e3902178">OpenSim::CMC_Task</a>, <a class="el" href="classOpenSim_1_1RRATool.html#acf2221861a852f3ce4f5bc9158fc5d13">OpenSim::RRATool</a>, <a class="el" href="classOpenSim_1_1GCVSpline.html#af1207edd76512fb8c486581517989545">OpenSim::GCVSpline</a>, <a class="el" href="classOpenSim_1_1SimmSpline.html#a8cc7ef3aec9dc712e958cf8c92f615d2">OpenSim::SimmSpline</a>, <a class="el" href="classOpenSim_1_1PiecewiseLinearFunction.html#a47de174140f6310a24a9c74da6d4e5d0">OpenSim::PiecewiseLinearFunction</a>, <a class="el" href="classOpenSim_1_1InverseKinematicsTool.html#a5537449bfc980395d0cb3b691e21356e">OpenSim::InverseKinematicsTool</a>, <a class="el" href="classOpenSim_1_1PrescribedForce.html#a0af1c696ef69c561025d6e2bcdfd53f2">OpenSim::PrescribedForce</a>, <a class="el" href="classOpenSim_1_1PathActuator.html#a241f27964d1c4ac1f73e3c2fc4710cec">OpenSim::PathActuator</a>, <a class="el" href="classOpenSim_1_1ForwardTool.html#a5f975f8479377ba7600a12f7e0c82d14">OpenSim::ForwardTool</a>, <a class="el" href="classOpenSim_1_1ExternalForce.html#adf0ebbf927427f7037bad81af709f1fa">OpenSim::ExternalForce</a>, <a class="el" href="classOpenSim_1_1MovingPathPoint.html#ac431aa34186cc637033b1bdc17819551">OpenSim::MovingPathPoint</a>, <a class="el" href="classOpenSim_1_1CMC__Joint.html#a359b27b2bf1c3414263dae587b262370">OpenSim::CMC_Joint</a>, <a class="el" href="classOpenSim_1_1InverseDynamicsTool.html#a6376f837afb597f81fdfa1c4e0e07dc0">OpenSim::InverseDynamicsTool</a>, <a class="el" href="classOpenSim_1_1CMC__Point.html#a0df3c481083e279f353e01708c9e23ea">OpenSim::CMC_Point</a>, <a class="el" href="classOpenSim_1_1ExternalLoads.html#aaa8013d33086ac48bc1dea03db973beb">OpenSim::ExternalLoads</a>, <a class="el" href="classOpenSim_1_1CustomJoint.html#addbdba2a7cf4498708cfd5cbf66131db">OpenSim::CustomJoint</a>, and <a class="el" href="classOpenSim_1_1ConditionalPathPoint.html#a847081dc5b5ddbcc2684c5cc5283d48b">OpenSim::ConditionalPathPoint</a>.</p>

</div>
</div>
<a class="anchor" id="a0bad202ee6d57acbbcc28c2b51cf7413"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OpenSim::Object::updateXMLNode </td>
          <td>(</td>
          <td class="paramtype">SimTK::Xml::Element &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize this object into the XML node that represents it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent XML node of this object. Sending in a parent node allows an XML node to be generated for this object if it doesn't already have one. If no parent node is supplied and this object doesn't already have an XML node, this object will become the root node for a new XML document. If this object already has an XML node associated with it, no new nodes are ever generated and the parent node is not used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe46905179b5d21f37c9b20f5ad70ffb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOpenSim_1_1VisibleObject.html">VisibleObject</a>* OpenSim::Object::updDisplayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get Non const pointer to <a class="el" href="classOpenSim_1_1VisibleObject.html" title="Class VisibleObject is intended to be used as the base class for all Visible objects that subclass Ob...">VisibleObject</a> </p>

<p>Reimplemented in <a class="el" href="classOpenSim_1_1ContactGeometry.html#a4bb0179a8a3b4eb7044f2605662f2be1">OpenSim::ContactGeometry</a>, <a class="el" href="classOpenSim_1_1PathPoint.html#a67941738f8ea9b01d9bb5c9f71e8c8fb">OpenSim::PathPoint</a>, <a class="el" href="classOpenSim_1_1Body.html#a346f28034a9802f26c3e3fe277cc19e2">OpenSim::Body</a>, and <a class="el" href="classOpenSim_1_1Marker.html#a5f1e007a9b028c3a8b6c3defad5c53c2">OpenSim::Marker</a>.</p>

</div>
</div>
<a class="anchor" id="afd5324b6c5432c4c37619afc29996136"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1XMLDocument.html">XMLDocument</a>* OpenSim::Object::updDocument </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a writable pointer to the document (if any) associated with this object. </p>

</div>
</div>
<a class="anchor" id="a351933e7ddc7a7e761e2a8a9cd12728b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp; OpenSim::Object::updProperty </td>
          <td>(</td>
          <td class="paramtype">const PropertyIndex &amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get property of known type <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a>&lt;T&gt; as a writable reference; the property must be present and have the right type. </p>
<p>This is primarily used by the <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> declaration macros for fast access to properties. </p>

</div>
</div>
<a class="anchor" id="ac3f81ef13cb278c49785cbb2236cc2b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&amp; OpenSim::Object::updPropertyByIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>propertyIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a writable reference to a property by its index number, returned as an <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a>. </p>

</div>
</div>
<a class="anchor" id="a62268af4017fc9d547ae718b3cb3733d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&amp; OpenSim::Object::updPropertyByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a writable reference to a property by its name, returned as an <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a>. </p>
<p>An exception is thrown if no property by this name is present in this Object. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ab75c37552f6feacddf9fc1d9a7c08cbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_ABSTRACT_OBJECT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ConcreteClass, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SuperClass&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_OBJECT_ANY_DEFS(ConcreteClass, SuperClass);                            \</div>
<div class="line">OpenSim_OBJECT_NONTEMPLATE_DEFS(ConcreteClass, SuperClass);                    \</div>
<div class="line">OpenSim_OBJECT_ABSTRACT_DEFS(ConcreteClass);</div>
</div><!-- fragment -->
<p>Macro to be included as the first line of the class declaration for any still-abstract class that derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>. </p>
<p>These are classes that represent categories of objects, like <a class="el" href="classOpenSim_1_1Function.html">Function</a> and <a class="el" href="classOpenSim_1_1ModelComponent.html" title="This defines the abstract ModelComponent class, which is used to add computational components to the ...">ModelComponent</a>. This macro leaves <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> pure virtuals <a class="el" href="classOpenSim_1_1Object.html#af221c900c5447df9928f1786469ef1b8" title="Create a new heap-allocated copy of the concrete object to which this Object refers. ">clone()</a> and <a class="el" href="classOpenSim_1_1Object.html#a56f3462342f51392a34cb4f0787ae2b7" title="Returns the class name of the concrete Object-derived class of the actual object referenced by this O...">getConcreteClassName()</a> unimplemented, however it does redeclare the return type of <a class="el" href="classOpenSim_1_1Object.html#af221c900c5447df9928f1786469ef1b8" title="Create a new heap-allocated copy of the concrete object to which this Object refers. ">clone()</a> to be ConcreteClass*. </p>

</div>
</div>
<a class="anchor" id="af7bc131913e859c757561270bb3adb86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_ABSTRACT_OBJECT_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ConcreteClass, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TArg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SuperClass&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_OBJECT_ANY_DEFS(ConcreteClass, SuperClass);                            \</div>
<div class="line">OpenSim_OBJECT_TEMPLATE_DEFS(ConcreteClass, TArg, SuperClass);                 \</div>
<div class="line">OpenSim_OBJECT_ABSTRACT_DEFS(ConcreteClass);</div>
</div><!-- fragment -->
<p>Macro to be included as the first line of the class declaration for any templatized, still-abstract class that derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>. </p>

</div>
</div>
<a class="anchor" id="a13075f96c92f1a0f18b791adf0fa255b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_CONCRETE_OBJECT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ConcreteClass, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SuperClass&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_OBJECT_ANY_DEFS(ConcreteClass, SuperClass);                            \</div>
<div class="line">OpenSim_OBJECT_NONTEMPLATE_DEFS(ConcreteClass, SuperClass);                    \</div>
<div class="line">OpenSim_OBJECT_CONCRETE_DEFS(ConcreteClass);</div>
</div><!-- fragment -->
<p>Macro to be included as the first line of the class declaration for any non-templatized, concrete class that derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>. </p>
<p>You should use this for any such class, even if you intend to derive more specific concrete objects from it. Don't use this for a still-abstract class, or a templatized concrete class like <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a>&lt;T&gt;. </p>

</div>
</div>
<a class="anchor" id="a04a016239bdc0a855927f706eca78876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">#define OpenSim_DECLARE_CONCRETE_OBJECT_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ConcreteClass, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TArg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SuperClass&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">OpenSim_OBJECT_ANY_DEFS(ConcreteClass, SuperClass);                            \</div>
<div class="line">OpenSim_OBJECT_TEMPLATE_DEFS(ConcreteClass, TArg, SuperClass);                 \</div>
<div class="line">OpenSim_OBJECT_CONCRETE_DEFS(ConcreteClass);</div>
</div><!-- fragment -->
<p>Macro to be included as the first line of the class declaration for any templatized, concrete class that derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>, like <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a>&lt;T&gt;. </p>

</div>
</div>
<a class="anchor" id="a89a6ee4ca0d4b2502e469e5ae9bce0c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>aOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>aObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the type and name of this object into the given output stream. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a22e666ea5837cc9bfd8818b86b35e4ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1PropertySet.html">PropertySet</a> OpenSim::Object::_propertySet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OBSOLETE: <a class="el" href="classOpenSim_1_1Property__Deprecated.html">Property_Deprecated</a> set for serializable member variables of this and derived classes. </p>

</div>
</div>
<a class="anchor" id="a84a2e7e58491709482729c7d52b90f21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string OpenSim::Object::DEFAULT_NAME</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name used for default objects when they are serialized. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/ReleaseEnv/src/OpenSim32Branch/OpenSim/Common/Object.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
</body>
</html>
