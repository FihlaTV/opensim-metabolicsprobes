<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenSim: OpenSim::SegmentedQuinticBezierToolkit Class Reference</title>
<link href="opensim.css" rel="stylesheet" type="text/css" />
<link href="lightbox.css" rel="stylesheet" type="text/css" />
<link href="bootstrap3/css/bootstrap.min.css" rel="stylesheet">
<script src="jquery-2.1.0.min.js"></script>
<script src="bootstrap3/js/bootstrap.min.js"></script>
<script src="lightbox.js"></script>
<script type="text/javascript" src="typeahead.min.js"></script>
<script src="hogan-2.0.0.js"></script>
<script type="text/javascript">
  window.onhashchange = function() {
  if (window.location.hash)
      window.scrollBy(0, -50);
  }
  if (window.location.hash)
  {
    window.scrollBy(0, -50);
  }
$( document ).ready(function() {
  $("#MSearchBox").hide();
  $("div.headertitle").addClass("page-header");
  $("div.title").addClass("h1");
  $('li > a[href="index.html"] > span').before("<i class='fa fa-cog'></i> ");
  $('li > a[href="index.html"] > span').text("OpenSim");
  $('li > a[href="modules.html"] > span').before("<i class='fa fa-square'></i> ");
  $('li > a[href="namespaces.html"] > span').before("<i class='fa fa-bars'></i> ");
  $('li > a[href="annotated.html"] > span').before("<i class='fa fa-list-ul'></i> ");
  $('li > a[href="classes.html"] > span').before("<i class='fa fa-book'></i> ");
  $('li > a[href="inherits.html"] > span').before("<i class='fa fa-sitemap'></i> ");
  $('li > a[href="functions.html"] > span').before("<i class='fa fa-list'></i> ");
  $('li > a[href="functions_func.html"] > span').before("<i class='fa fa-list'></i> ");
  $('li > a[href="functions_vars.html"] > span').before("<i class='fa fa-list'></i> ");
  $('li > a[href="functions_enum.html"] > span').before("<i class='fa fa-list'></i> ");
  $('li > a[href="functions_eval.html"] > span').before("<i class='fa fa-list'></i> ");
  $('img[src="ftv2ns.png"]').replaceWith('<span class="label label-danger">N</span> ');
  $('img[src="ftv2cl.png"]').replaceWith('<span class="label label-danger">C</span> ');
  $("ul.tablist").addClass("nav nav-pills nav-justified");
  $("ul.tablist").css("margin-top", "0.5em");
  $("ul.tablist").css("margin-bottom", "0.5em");
  $("li.current").addClass("active");
  $("iframe").attr("scrolling", "yes");
  $("#nav-path > ul").addClass("breadcrumb");
  $("table.params").addClass("table");
  $("div.ingroups").wrapInner("<small></small>");
  $("div.levels").css("margin", "0.5em");
  $("div.levels > span").addClass("btn btn-default btn-xs");
  $("div.levels > span").css("margin-right", "0.25em");
  $("table.directory").addClass("table table-striped");
  $("div.summary > a").addClass("btn btn-default btn-xs");
  $("table.fieldtable").addClass("table");
  $(".fragment").addClass("well");
  $(".memitem").addClass("panel panel-default");
  $(".memproto").addClass("panel-heading");
  $(".memdoc").addClass("panel-body");
  $("span.mlabel").addClass("label label-info");
  $("table.memberdecls").addClass("table");
  $("[class^=memitem]").addClass("active");
  $("div.ah").addClass("btn btn-default");
  $("span.mlabels").addClass("pull-right");
  $("table.mlabels").css("width", "100%")
  $("td.mlabels-right").addClass("pull-right");
  $("div.ttc").addClass("panel panel-info");
  $("div.ttname").addClass("panel-heading");
  $("div.ttdef,div.ttdoc,div.ttdeci").addClass("panel-body");
$("#search").typeahead([
    {
      name: 'opensim-search',
      valueKey: 'title',
      remote: { url: 'query?q=%QUERY&teaser=body&pagesize=1000',
      filter: function(p) {
        dat = [];
        for(i=0; i < p.hits.length; i++)
        {
          var pn = p.hits[i].document;
          pn.href = p.hits[i].id;
          dat.push(pn);
        }
        return dat;
      }
    },
      template: '<strong>{{title}}</strong><p>{{{teaser}}}</p>',
      engine: Hogan,
      limit: 1000
    }
    ]).on("typeahead:selected", (function (e, datum){
      window.location = datum.href;
    }));
    $('.typeahead.input-sm').siblings('input.tt-hint').addClass('hint-small');
    $('.typeahead.input-lg').siblings('input.tt-hint').addClass('hint-large');
  $.ajax({url : "ping", type: "GET", error : function() {
    var prt = $("#MSearchBox").parent();
    $(".twitter-typeahead").replaceWith($("#MSearchBox").show());
    prt.remove();
  }, success: function() {
    $("#MSearchBox").parent().remove();
    $(".nav>li").css("width", "266.667px");
  }   });
});
var initNavTree = function(a,b) { } 
function toggleVisibility(linkObj)
{
 var base = $(linkObj).attr('id');
 var summary = $('#'+base+'-summary');
 var content = $('#'+base+'-content');
 var trigger = $('#'+base+'-trigger');
 var src=$(trigger).attr('src');
 if (content.is(':visible')===true) {
   content.hide();
   summary.show();
   $(linkObj).addClass('closed').removeClass('opened');
   $(trigger).attr('src',src.substring(0,src.length-8)+'closed.png');
 } else {
   content.show();
   summary.hide();
   $(linkObj).removeClass('closed').addClass('opened');
   $(trigger).attr('src',src.substring(0,src.length-10)+'open.png');
 } 
 return false;
}
function updateStripes()
{
  $('table.directory tr').
       removeClass('even').filter(':visible:even').addClass('even');
}
function toggleLevel(level)
{
  $('table.directory tr').each(function(){ 
    var l = this.id.split('_').length-1;
    var i = $('#img'+this.id.substring(3));
    var a = $('#arr'+this.id.substring(3));
    if (l<level+1) {
      i.attr('src','ftv2folderopen.png');
      a.attr('src','ftv2mnode.png');
      $(this).show();
    } else if (l==level+1) {
      i.attr('src','ftv2folderclosed.png');
      a.attr('src','ftv2pnode.png');
      $(this).show();
    } else {
      $(this).hide();
    }
  });
  updateStripes();
}
function toggleFolder(id)
{
  //The clicked row
  var currentRow = $('#row_'+id);
  var currentRowImages = currentRow.find("img");
  //All rows after the clicked row
  var rows = currentRow.nextAll("tr");
  //Only match elements AFTER this one (can't hide elements before)
  var childRows = rows.filter(function() {
    var re = new RegExp('^row_'+id+'\\d+_$', "i"); //only one sub
    return this.id.match(re);
  });
  //First row is visible we are HIDING
  if (childRows.filter(':first').is(':visible')===true) {
    currentRowImages.filter("[id^=arr]").attr('src', 'ftv2pnode.png');
    currentRowImages.filter("[id^=img]").attr('src', 'ftv2folderclosed.png');
    rows.filter("[id^=row_"+id+"]").hide();
  } else { //We are SHOWING
    //All sub images
    var childImages = childRows.find("img");
    var childImg = childImages.filter("[id^=img]");
    var childArr = childImages.filter("[id^=arr]");
    currentRow.find("[id^=arr]").attr('src', 'ftv2mnode.png'); //open row
    currentRow.find("[id^=img]").attr('src', 'ftv2folderopen.png'); //open row
    childImg.attr('src','ftv2folderclosed.png'); //children closed
    childArr.attr('src','ftv2pnode.png'); //children closed
    childRows.show(); //show all children
  }
  updateStripes();
}
function toggleInherit(id)
{
  var rows = $('tr.inherit.'+id);
  var img = $('tr.inherit_header.'+id+' img');
  var src = $(img).attr('src');
  if (rows.filter(':first').is(':visible')===true) {
    rows.css('display','none');
    $(img).attr('src',src.substring(0,src.length-8)+'closed.png');
  } else {
    rows.css('display','table-row'); // using show() causes jump in firefox
    $(img).attr('src',src.substring(0,src.length-10)+'open.png');
  }
}
$(function() {
$(".dyncontent img").each(function () {
  $(this).wrap("<a href='" + $(this).attr("src") + "'></a>");
  $(".dyncontent a").click(function(e) { e.preventDefault(); $(this).ekkoLightbox();  });
} );
  diag = $("map").parent().children("a").children("img");
  if (diag != 'undefined')
  {
      diag.clone().load(function() { 
      ratio = diag.width() / this.width;
      $("area").each(function () {
          cr = $(this).attr("coords").split(",");
          for(l=0; l < cr.length; l++) {
            cr[l] = parseInt(cr[l]) * ratio;
          }
          $(this).attr("coords", cr.join(','));
      })
      console.log(ratio); 
    });
  }
});
</script>
<style type="text/css">
  body
  {
    width: 800px;
    margin: 0 auto;
  }
  img
  {
    max-width: 800px;
  }
  #container
  {
    margin-top: 70px;
  }
.twitter-typeahead .tt-hint
{
    display: block;
    height: 34px;
    padding: 6px 12px;
    font-size: 14px;
    line-height: 1.428571429;
    border: 1px solid transparent;
    border-radius:4px;
}
.twitter-typeahead .hint-small
{
    height: 30px;
    padding: 5px 10px;
    font-size: 12px;
    border-radius: 3px;
    line-height: 1.5;
}
.twitter-typeahead .hint-large
{
    height: 45px;
    padding: 10px 16px;
    font-size: 18px;
    border-radius: 6px;
    line-height: 1.33;
}
.twitter-typeahead {
    width: 100%;
    position: relative;
}
.twitter-typeahead .tt-query,
.twitter-typeahead .tt-hint {
    margin-bottom: 0;
    width:100%;
    height: 34px;
    position: absolute;
    top:0;
    left:0;
}
.twitter-typeahead .tt-hint {
    color:#a1a1a1;
    z-index: 1;
    padding: 6px 12px;
    border:1px solid transparent;
}
.twitter-typeahead .tt-query {
    z-index: 2;
    border-radius: 4px!important;
}
.tt-dropdown-menu {
    left: auto !important;
    right: 0px !important;
    overflow-y: auto;
    max-height: 400px;
    min-width: 160px;
    margin-top: 2px;
    padding: 5px 0;
    background-color: #fff;
    border: 1px solid #ccc;
    border: 1px solid rgba(0,0,0,.2);
    *border-right-width: 2px;
    *border-bottom-width: 2px;
    -webkit-border-radius: 6px;
    -moz-border-radius: 6px;
    border-radius: 6px;
    -webkit-box-shadow: 0 5px 10px rgba(0,0,0,.2);
    -moz-box-shadow: 0 5px 10px rgba(0,0,0,.2);
    box-shadow: 0 5px 10px rgba(0,0,0,.2);
    -webkit-background-clip: padding-box;
    -moz-background-clip: padding;
    background-clip: padding-box;
}
.tt-suggestion {
    display: block;
    padding: 3px 20px;
}
.tt-suggestion.tt-is-under-cursor {
    color: #fff;
    background-color: #0081c2;
    background-image: -moz-linear-gradient(top, #0088cc, #0077b3);
    background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#0088cc), to(#0077b3));
    background-image: -webkit-linear-gradient(top, #0088cc, #0077b3);
    background-image: -o-linear-gradient(top, #0088cc, #0077b3);
    background-image: linear-gradient(to bottom, #0088cc, #0077b3);
    background-repeat: repeat-x;
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#ff0088cc', endColorstr='#ff0077b3', GradientType=0)
}
.tt-suggestion.tt-is-under-cursor a {
    color: #fff;
}
.tt-suggestion p {
    margin: 0;
}
.sc-em
{
  font-weight: bold;
}
#MSearchResultsWindow
{
  top: 51px !important;
  position: fixed !important;
}
</style>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
</head>
<body>
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">OpenSim Documentation</a>
        </div>
          <form class="navbar-form navbar-right">
              <input type="search" placeholder="Search" class="form-control" id="search">
          </form>
      </div>
    </div>
  <div id="container">
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classOpenSim_1_1SegmentedQuinticBezierToolkit.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classOpenSim_1_1SegmentedQuinticBezierToolkit-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenSim::SegmentedQuinticBezierToolkit Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a low level Quintic Bezier curve class that contains functions to design continuous sets of 'C' shaped Bezier curves, and to evaluate their values and derivatives.  
 <a href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#details">More...</a></p>

<p><code>#include &lt;SegmentedQuinticBezierToolkit.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad3a52714898f2e1e96eaf33ffcd0e80d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#ad3a52714898f2e1e96eaf33ffcd0e80d">calcU</a> (double ax, const SimTK::Vector &amp;bezierPtsX, const SimTK::Spline &amp;splineUX, double tol, int maxIter)</td></tr>
<tr class="memdesc:ad3a52714898f2e1e96eaf33ffcd0e80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will compute the u value that correesponds to the given x for a quintic Bezier curve.  <a href="#ad3a52714898f2e1e96eaf33ffcd0e80d">More...</a><br/></td></tr>
<tr class="separator:ad3a52714898f2e1e96eaf33ffcd0e80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5455c36b9ed2eec11c3d056138b6154"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#ad5455c36b9ed2eec11c3d056138b6154">calcIndex</a> (double x, const SimTK::Matrix &amp;bezierPtsX)</td></tr>
<tr class="memdesc:ad5455c36b9ed2eec11c3d056138b6154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of Bezier curve control points, return the index of the set of control points that x lies within.  <a href="#ad5455c36b9ed2eec11c3d056138b6154">More...</a><br/></td></tr>
<tr class="separator:ad5455c36b9ed2eec11c3d056138b6154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fd3f3d4e8286af58780461ecf23a51"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#ab7fd3f3d4e8286af58780461ecf23a51">calcIndex</a> (double x, const SimTK::Array_&lt; SimTK::Vector &gt; &amp;bezierPtsX)</td></tr>
<tr class="separator:ab7fd3f3d4e8286af58780461ecf23a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa554df1eeb3b103e77a7a90f41895b35"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#aa554df1eeb3b103e77a7a90f41895b35">calcQuinticBezierCurveVal</a> (double u, const SimTK::Vector &amp;pts)</td></tr>
<tr class="memdesc:aa554df1eeb3b103e77a7a90f41895b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the value of a quintic Bezier curve at value u.  <a href="#aa554df1eeb3b103e77a7a90f41895b35">More...</a><br/></td></tr>
<tr class="separator:aa554df1eeb3b103e77a7a90f41895b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b62b522472a4b6ee49f5ec53ebc16ab"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#a3b62b522472a4b6ee49f5ec53ebc16ab">calcQuinticBezierCurveDerivU</a> (double u, const SimTK::Vector &amp;pts, int order)</td></tr>
<tr class="memdesc:a3b62b522472a4b6ee49f5ec53ebc16ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the value of a quintic Bezier derivative curve at value u.  <a href="#a3b62b522472a4b6ee49f5ec53ebc16ab">More...</a><br/></td></tr>
<tr class="separator:a3b62b522472a4b6ee49f5ec53ebc16ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf8bca24ed57416dfadfccbb436c10a"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#a9bf8bca24ed57416dfadfccbb436c10a">calcQuinticBezierCurveDerivDYDX</a> (double u, const SimTK::Vector &amp;xpts, const SimTK::Vector &amp;ypts, int order)</td></tr>
<tr class="memdesc:a9bf8bca24ed57416dfadfccbb436c10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the value of dydx of a quintic Bezier curve derivative at u.  <a href="#a9bf8bca24ed57416dfadfccbb436c10a">More...</a><br/></td></tr>
<tr class="separator:a9bf8bca24ed57416dfadfccbb436c10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13248db7257190f12e97689b9f4b3982"><td class="memItemLeft" align="right" valign="top">static SimTK::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#a13248db7257190f12e97689b9f4b3982">calcQuinticBezierCornerControlPoints</a> (double x0, double y0, double dydx0, double x1, double y1, double dydx1, double curviness)</td></tr>
<tr class="memdesc:a13248db7257190f12e97689b9f4b3982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the location of quintic Bezier curve control points to create a C shaped curve.  <a href="#a13248db7257190f12e97689b9f4b3982">More...</a><br/></td></tr>
<tr class="separator:a13248db7257190f12e97689b9f4b3982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e454dae42039ea47a9c3ff1c21f3f3"><td class="memItemLeft" align="right" valign="top">static SimTK::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#a09e454dae42039ea47a9c3ff1c21f3f3">calcNumIntBezierYfcnX</a> (const SimTK::Vector &amp;vX, double ic0, double intAcc, double uTol, int uMaxIter, const SimTK::Matrix &amp;mX, const SimTK::Matrix &amp;mY, const SimTK::Array_&lt; SimTK::Spline &gt; &amp;aSplineUX, bool flag_intLeftToRight, const std::string &amp;name)</td></tr>
<tr class="memdesc:a09e454dae42039ea47a9c3ff1c21f3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function numerically integrates the Bezier curve y(x).  <a href="#a09e454dae42039ea47a9c3ff1c21f3f3">More...</a><br/></td></tr>
<tr class="separator:a09e454dae42039ea47a9c3ff1c21f3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a low level Quintic Bezier curve class that contains functions to design continuous sets of 'C' shaped Bezier curves, and to evaluate their values and derivatives. </p>
<p>A set in this context is used to refer to 2 or more quintic Bezier curves that are continuously connected to eachother to form one smooth curve, hence the name QuinticBezierSet.</p>
<p>In the special case when this class is being used to generate and evaluate 2D Bezier curves, that is x(u) and y(u), there are also functions to evaluate y(x), the first six derivatives of y(x), and also the first integral of y(x).</p>
<p>This class was not designed to be a stand alone Quintic Bezier class, but rather was developed out of necessity to model muscles. I required curves that, when linearly extrapolated, were C2 continuous, and by necessity I had to use quintic Bezier curves. In addition, the curves I was developing were functions in x,y space, allowing many of the methods (such as the evaluation of y(x) given that x(u) and y(u), the derivatives of y(x), and its first integral) to be developed, though in general this can't always be done.</p>
<p>I have parcelled all of these tools into their own class so that others may more easily use and develop this starting point for their own means. I used the following text during the development of this code:</p>
<p>Mortenson, Michael E (2006). Geometric Modeling Third Edition. Industrial Press Inc., New York. Chapter 4 was quite helpful.</p>
<p><b>Future Upgrades</b></p>
<p>1. Analytical Inverse to x(u).</p>
<p>I think this is impossible because it is not possible, in general, to find the roots to a quintic polynomial, however, this fact may not preclude forming the inverse curve. The impossibility of finding the roots to a quintic polynomial was proven by Abel (Abel's Impossibility Theorem) and Galois</p>
<p><a href="http://mathworld.wolfram.com/QuinticEquation.html">http://mathworld.wolfram.com/QuinticEquation.html</a></p>
<p>At the moment I am approximating the curve u(x) using cubic splines to return an approximate value for u(x), which I polish using Newton's method to the desired precision.</p>
<p>2. Analytical Integral of y(x)</p>
<p>This is possible using the Divergence Theorem applied to 2D curves. A nice example application is shown in link 2 for computing the area of a closed cubic Bezier curve. While I have been able to get the simple examples to work, I have failed to successfully compute the area under a quintic Bezier curve correctly. I ran out of time trying to fix this problem, and so at the present time I am numerically computing the integral at a number of knot points and then evaluating the spline to compute the integral value.</p>
<p>a. <a href="http://en.wikipedia.org/wiki/Divergence_theorem">http://en.wikipedia.org/wiki/Divergence_theorem</a> b. <a href="http://objectmix.com/graphics/133553-area-closed-bezier-curve.html">http://objectmix.com/graphics/133553-area-closed-bezier-curve.html</a></p>
<p>3. calcU</p>
<p>Currently the Bezier curve value and its derivative are computed separately to evaluate f and df in the Newton iteration to solve for u(x). Code optimized to compute both of these quantites at the same time could cut the cost of evaluating x(u) and dx/du in half. Since these quantities are evaluated in an iterative loop, this one change could yield substantial computational savings.</p>
<p>4. calcIndex</p>
<p>The function calcIndex computes which spline the contains the point of interest. This function has been implemented assuming a small number of Bezier curve sets, and so it simply linearly scans through the sets to determine the correct one to use. This function should be upgraded to use the bisection method if large quintic Bezier curve sets are desired.</p>
<p>5. The addition of additional Bezier control point design algorithms, to create 'S' shaped curves, and possibly do subdivision.</p>
<p>6. Low level Code Optimization</p>
<p>I have exported all of the low level code as optimized code from Maple. Although the code produced using this means is reasonably fast, it is usally possible to obtain superiour performance (and sometimes less round off error) by doing this work by hand.</p>
<p><b>Computational Cost Details</b> All computational costs assume the following operation costs:</p>
<pre class="fragment">Operation Type   : #flops
+,-,=,Boolean Op : 1 
               / : 10
             sqrt: 20
             trig: 40
</pre><p>These relative weightings will vary processor to processor, and so any of the quoted computational costs are approximate.</p>
<dl class="section author"><dt>Author</dt><dd>Matt Millard </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.0 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad5455c36b9ed2eec11c3d056138b6154"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenSim::SegmentedQuinticBezierToolkit::calcIndex </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Matrix &amp;&#160;</td>
          <td class="paramname"><em>bezierPtsX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of Bezier curve control points, return the index of the set of control points that x lies within. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>A value that is interpolated by the set of Bezier curves </td></tr>
    <tr><td class="paramname">bezierPtsX</td><td>A matrix of 6xn Bezier control points</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classOpenSim_1_1Exception.html">OpenSim::Exception</a></td><td>-If the index is not located within this set of Bezier points</td></tr>
  </table>
  </dd>
</dl>
<p>Given a set of Bezier curve control points, return the index of the set of control points that x lies within. This function has been coded assuming a small number of Bezier curve sets (less than 10), and so, it simply scans through the Bezier curve sets until it finds the correct one.</p>
<p><b>Computational Costs</b> Quoted for a Bezier curve set containing 1 to 5 curves. </p>
<pre class="fragment">    ~9-25
</pre><p><b>Example:</b> </p>
<div class="fragment"><div class="line">SimTK::Matrix mX(6,2);</div>
<div class="line"></div>
<div class="line"><span class="comment">//The first set of spline points</span></div>
<div class="line">    mX(0,0) = -2;</div>
<div class="line">    mX(1,0) = -1;</div>
<div class="line">    mX(2,0) = -1;</div>
<div class="line">    mX(3,0) = 1;</div>
<div class="line">    mX(4,0) = 1;</div>
<div class="line">    mX(5,0) = 2;</div>
<div class="line"><span class="comment">//The second set of spline points</span></div>
<div class="line">    mX(0,1) = 2;</div>
<div class="line">    mX(1,1) = 3;</div>
<div class="line">    mX(2,1) = 3;</div>
<div class="line">    mX(3,1) = 5;</div>
<div class="line">    mX(4,1) = 5;</div>
<div class="line">    mX(5,1) = 6;</div>
<div class="line"></div>
<div class="line"><span class="comment">//The value of x for which we want the index for</span></div>
<div class="line"><span class="keywordtype">double</span> xVal = 1.75;</div>
<div class="line"><span class="keywordtype">int</span> idx  = <a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#ad5455c36b9ed2eec11c3d056138b6154">SegmentedQuinticBezierToolkit::calcIndex</a>(xVal,mX);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab7fd3f3d4e8286af58780461ecf23a51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenSim::SegmentedQuinticBezierToolkit::calcIndex </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Array_&lt; SimTK::Vector &gt; &amp;&#160;</td>
          <td class="paramname"><em>bezierPtsX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a09e454dae42039ea47a9c3ff1c21f3f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimTK::Matrix OpenSim::SegmentedQuinticBezierToolkit::calcNumIntBezierYfcnX </td>
          <td>(</td>
          <td class="paramtype">const SimTK::Vector &amp;&#160;</td>
          <td class="paramname"><em>vX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ic0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>intAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>uTol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>uMaxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Matrix &amp;&#160;</td>
          <td class="paramname"><em>mX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Matrix &amp;&#160;</td>
          <td class="paramname"><em>mY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Array_&lt; SimTK::Spline &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSplineUX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag_intLeftToRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function numerically integrates the Bezier curve y(x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vX</td><td>Values of x to evaluate the integral of y(x) </td></tr>
    <tr><td class="paramname">ic0</td><td>The initial value of the integral </td></tr>
    <tr><td class="paramname">intAcc</td><td>Accuracy of the integrated solution </td></tr>
    <tr><td class="paramname">uTol</td><td>Tolerance on the calculation of the intermediate u term </td></tr>
    <tr><td class="paramname">uMaxIter</td><td>Maximum number of iterations allowed for u to reach its desired tolerance. </td></tr>
    <tr><td class="paramname">mX</td><td>The 6xn matrix of Bezier control points for x(u) </td></tr>
    <tr><td class="paramname">mY</td><td>The 6xn matrix of Bezier control points for y(u) </td></tr>
    <tr><td class="paramname">aSplineUX</td><td>The array of spline objects that approximate u(x) on each Bezier interval </td></tr>
    <tr><td class="paramname">flag_intLeftToRight</td><td>Setting this flag to true will evaluate the integral from the left most point to the right most point. Setting this flag to false will cause the integral to be evaluated from right to left. </td></tr>
    <tr><td class="paramname">name</td><td>Name of caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SimTK::Matrix Col 0: X vector, Col 1: int(y(x))</dd></dl>
<p>This function numerically integrates the Bezier curve y(x), when really both x and y are specified in terms of u. Evaluate the integral at the locations specified in vX and return the result.</p>
<p><b>Computational Costs</b></p>
<p>This the expense of this function depends on the number of points in vX, the points for which the integral y(x) must be calculated. The integral is evaluated using a Runge Kutta 45 integrator, and so each point requires 6 function evaluations. (<a href="http://en.wikipedia.org/wiki/Dormand%E2%80%93Prince_method">http://en.wikipedia.org/wiki/Dormand%E2%80%93Prince_method</a>)</p>
<p>The cost of evaluating 1 Bezier curve y(x) scales with the number of points in xVal: </p>
<pre class="fragment">    ~1740 flops per point
</pre><p>The example below is quite involved, but just so it can show you an example of how to create the array of Spline objects that approximate the function u(x). Although the example has been created for only 1 Bezier curve set, simply changing the size and entries of the matricies _mX and _mY will allow multiple sets to be integrated.</p>
<p><b>Example:</b> </p>
<div class="fragment"><div class="line"><span class="comment">//Integrator and u tolerance settings</span></div>
<div class="line"><span class="keywordtype">double</span> INTTOL = 1e-12;</div>
<div class="line"><span class="keywordtype">double</span> UTOL   = 1e-14;</div>
<div class="line"><span class="keywordtype">int</span>    MAXITER= 10;</div>
<div class="line"></div>
<div class="line"><span class="comment">//Make up a Bezier curve - these happen to be the control points</span></div>
<div class="line"><span class="comment">//for a tendon curve</span></div>
<div class="line">SimTK::Matrix _mX(6,1), _mY(6,1);</div>
<div class="line">_mX(0)= 1;</div>
<div class="line">_mX(1)= 1.01164;</div>
<div class="line">_mX(2)= 1.01164;</div>
<div class="line">_mX(3)= 1.02364;</div>
<div class="line">_mX(4)= 1.02364;</div>
<div class="line">_mX(5)= 1.04;</div>
<div class="line"></div>
<div class="line">_mY(0) = 0;</div>
<div class="line">_mY(1) = 3.10862e-16;</div>
<div class="line">_mY(2) = 3.10862e-16;</div>
<div class="line">_mY(3) = 0.3;</div>
<div class="line">_mY(4) = 0.3;</div>
<div class="line">_mY(5) = 1;</div>
<div class="line"></div>
<div class="line">_numBezierSections = 1;</div>
<div class="line"><span class="keywordtype">bool</span> _intx0x1 = <span class="keyword">true</span>; <span class="comment">//Says we&#39;re integrating from x0 to x1</span></div>
<div class="line"><span class="comment"></span><span class="comment">//Generate the set of splines that approximate u(x)</span></div>
<div class="line"><span class="comment"></span>SimTK::Vector u(NUM_SAMPLE_PTS); <span class="comment">//Used for the approximate inverse</span></div>
<div class="line">SimTK::Vector x(NUM_SAMPLE_PTS); <span class="comment">//Used for the approximate inverse</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//Used to generate the set of knot points of the integral of y(x)    </span></div>
<div class="line">SimTK::Vector xALL(NUM_SAMPLE_PTS*_numBezierSections-(_numBezierSections-1));</div>
<div class="line">_arraySplineUX.resize(_numBezierSections);</div>
<div class="line"><span class="keywordtype">int</span> xidx = 0;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> s=0; s &lt; _numBezierSections; s++){</div>
<div class="line">    <span class="comment">//Sample the local set for u and x</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;NUM_SAMPLE_PTS;i++){</div>
<div class="line">        u(i) = ( (double)i )/( (double)(NUM_SAMPLE_PTS-1) );</div>
<div class="line">        x(i) = <a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#aa554df1eeb3b103e77a7a90f41895b35">SegmentedQuinticBezierToolkit::</a></div>
<div class="line"><a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#aa554df1eeb3b103e77a7a90f41895b35">            calcQuinticBezierCurveVal</a>(u(i),_mX(s),_name);            </div>
<div class="line">        <span class="keywordflow">if</span>(_numBezierSections &gt; 1){</div>
<div class="line">           <span class="comment">//Skip the last point of a set that has another set of points</span></div>
<div class="line">           <span class="comment">//after it. Why? The last point and the starting point of the</span></div>
<div class="line">           <span class="comment">//next set are identical in value.</span></div>
<div class="line">            <span class="keywordflow">if</span>(i&lt;(NUM_SAMPLE_PTS-1) || s == (_numBezierSections-1)){</div>
<div class="line">                xALL(xidx) = x(i);</div>
<div class="line">                xidx++;</div>
<div class="line">            }</div>
<div class="line">        }<span class="keywordflow">else</span>{</div>
<div class="line">            xALL(xidx) = x(i);                </div>
<div class="line">            xidx++;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">//Create the array of approximate inverses for u(x)    </span></div>
<div class="line">    _arraySplineUX[s] = SimTK::SplineFitter&lt;Real&gt;::</div>
<div class="line">        fitForSmoothingParameter(3,x,u,0).getSpline();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//Compute the integral of y(x) and spline the result    </span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">SimTK::Vector yInt =  <a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#a09e454dae42039ea47a9c3ff1c21f3f3">SegmentedQuinticBezierToolkit::</a></div>
<div class="line"><a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#a09e454dae42039ea47a9c3ff1c21f3f3">    calcNumIntBezierYfcnX</a>(xALL,0,INTTOL, UTOL, MAXITER,_mX, _mY,</div>
<div class="line">    _arraySplineUX,_name);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span>(_intx0x1==<span class="keyword">false</span>){</div>
<div class="line">    yInt = yInt*-1;</div>
<div class="line">    yInt = yInt - yInt(yInt.nelt()-1);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">_splineYintX = SimTK::SplineFitter&lt;Real&gt;::</div>
<div class="line">        fitForSmoothingParameter(3,xALL,yInt,0).getSpline();</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a13248db7257190f12e97689b9f4b3982"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static SimTK::Matrix OpenSim::SegmentedQuinticBezierToolkit::calcQuinticBezierCornerControlPoints </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dydx0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dydx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>curviness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the location of quintic Bezier curve control points to create a C shaped curve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>First intercept x location </td></tr>
    <tr><td class="paramname">y0</td><td>First intercept y location </td></tr>
    <tr><td class="paramname">dydx0</td><td>First intercept slope </td></tr>
    <tr><td class="paramname">x1</td><td>Second intercept x location </td></tr>
    <tr><td class="paramname">y1</td><td>Second intercept y location </td></tr>
    <tr><td class="paramname">dydx1</td><td>Second intercept slope </td></tr>
    <tr><td class="paramname">curviness</td><td>A parameter that ranges between 0 and 1 to denote a straight line or a curve </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classOpenSim_1_1Exception.html">OpenSim::Exception</a></td><td>-If the curviness parameter is less than 0, or greater than 1; -If the points and slopes are chosen so that an "S" shaped curve would be produced. This is tested by examining the points (x0,y0) and (x1,y1) together with the intersection (xC,yC) of the lines beginning at these points with slopes of dydx0 and dydx1 form a triangle. If the line segment from (x0,y0) to (x1,y1) is not the longest line segment, an exception is thrown. This is an overly conservative test as it prevents very deep 'V' shapes from being respresented.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SimTK::Matrix of 6 points Matrix(6,2) that correspond to the X, and Y control points for a quintic Bezier curve that has the above properties</dd></dl>
<p>Calculates the location of quintic Bezier curve control points to create a C shaped curve that intersects points 0 (x0, y0) and point 1 (x1, y1) with slopes dydx0 and dydx1 respectively, and a second derivative of 0. The curve that results can approximate a line (curviness = 0), or in a smooth C shaped curve (curviniess = 1)</p>
<p>The current implementation of this function is not optimized in anyway and has the following costs:</p>
<p><b>Computational Costs</b> </p>
<pre class="fragment">    ~55 flops
</pre><p><b>Example:</b> </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> x0 = 1;</div>
<div class="line"><span class="keywordtype">double</span> y0 = 0;</div>
<div class="line"><span class="keywordtype">double</span> dydx0 = 0;</div>
<div class="line"><span class="keywordtype">double</span> x1 = 1.04;</div>
<div class="line"><span class="keywordtype">double</span> y1 = 1;</div>
<div class="line"><span class="keywordtype">double</span> dydx1 = 43;</div>
<div class="line"><span class="keywordtype">double</span> c = 0.75;</div>
<div class="line"></div>
<div class="line">SimTK::Matrix p0 = <a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#a13248db7257190f12e97689b9f4b3982">SegmentedQuinticBezierToolkit::</a></div>
<div class="line"><a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#a13248db7257190f12e97689b9f4b3982">   calcQuinticBezierCornerControlPoints</a>(x0, y0, dydx0,x1,y1,dydx01,</div>
<div class="line">                                                         c);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a9bf8bca24ed57416dfadfccbb436c10a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenSim::SegmentedQuinticBezierToolkit::calcQuinticBezierCurveDerivDYDX </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vector &amp;&#160;</td>
          <td class="paramname"><em>xpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vector &amp;&#160;</td>
          <td class="paramname"><em>ypts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the value of dydx of a quintic Bezier curve derivative at u. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The u value of interest. Note that u must be [0,1] </td></tr>
    <tr><td class="paramname">xpts</td><td>The 6 control points associated with the x axis </td></tr>
    <tr><td class="paramname">ypts</td><td>The 6 control points associated with the y axis </td></tr>
    <tr><td class="paramname">order</td><td>The order of the derivative. Currently only orders from 1-6 can be evaluated </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classOpenSim_1_1Exception.html">OpenSim::Exception</a></td><td>-If u is outside [0,1] -If xpts is not 6 elements long -If ypts is not 6 elements long -If the order is less than 1 -If the order is greater than 6 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>value of (d^n y)/(dx^n) evaluated at u</td></tr>
  </table>
  </dd>
</dl>
<p>Calculates the value of dydx of a quintic Bezier curve derivative at u. Note that a 2D Bezier curve can have an infinite number of derivatives, because x and y are functions of u. Thus</p>
<pre class="fragment">dy/dx = (dy/du)/(dx/du)
d^2y/dx^2 = d/du(dy/dx)*du/dx
          = [(d^2y/du^2)*(dx/du) - (dy/du)*(d^2x/du^2)]/(dx/du)^2 
            *(1/(dx/du))
etc.
</pre><p><b>Computational Costs</b></p>
<p>This obviously only functions when the Bezier curve in question has a finite derivative. Additionally, higher order derivatives are more numerically expensive to evaluate than lower order derivatives. For example, here are the number of operations required to compute the following derivatives </p>
<pre class="fragment">    Name    : flops
    dy/dx   : ~102
    d2y/dx2 : ~194
    d3y/dx3 : ~321
    d4y/dx4 : ~426
    d5y/dx5 : ~564
    d6y/dx6 : ~739
</pre><p><b>Example:</b> </p>
<div class="fragment"><div class="line">SimTK::Vector vX(6), vY(6);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> u = 0.5;</div>
<div class="line"></div>
<div class="line">vX(0) = 1;</div>
<div class="line">vX(1) = 1.01164;</div>
<div class="line">vX(2) = 1.01164;</div>
<div class="line">vX(3) = 1.02364;</div>
<div class="line">vX(4) = 1.02364;</div>
<div class="line">vY(5) = 1.04;</div>
<div class="line"></div>
<div class="line">vY(0) = 0;</div>
<div class="line">vY(1) = 3e-16;</div>
<div class="line">vY(2) = 3e-16;</div>
<div class="line">vY(3) = 0.3;</div>
<div class="line">vY(4) = 0.3;</div>
<div class="line">vY(5) = 1;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">d2ydx2 = <a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#a9bf8bca24ed57416dfadfccbb436c10a">SegmentedQuinticBezierToolkit::calcQuinticBezierCurveDerivDYDX</a>(</div>
<div class="line">         u,vX, vY, 2);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3b62b522472a4b6ee49f5ec53ebc16ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenSim::SegmentedQuinticBezierToolkit::calcQuinticBezierCurveDerivU </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vector &amp;&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the value of a quintic Bezier derivative curve at value u. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The independent variable of a Bezier curve, which ranges between 0.0 and 1.0. </td></tr>
    <tr><td class="paramname">pts</td><td>The locations of the control points in 1 dimension. </td></tr>
    <tr><td class="paramname">order</td><td>The desired order of the derivative. Order must be &gt;= 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classOpenSim_1_1Exception.html">OpenSim::Exception</a></td><td>if -u is outside [0,1] -pts is not 6 elements long -if order is less than 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of du/dx of Bezier curve located at u.</dd></dl>
<p>Calculates the value of a quintic Bezier derivative curve at value u. This calculation is acheived by taking the derivative of the row vector uV and multiplying it by the 6x6 coefficient matrix associated with a quintic Bezier curve, by the vector of Bezier control points, pV, in a particular dimension.</p>
<p>Pseudo code for the first derivative (order == 1) would be </p>
<pre class="fragment">    uV = [5*u^4 4*u^3 3*u^2 2u 1 0];

    cM = [ -1     5   -10    10    -5     1;
            5   -20    30   -20     5     0;
          -10    30   -30    10     0     0;
           10   -20    10     0     0     0;
           -5     5     0     0     0     0;
            1     0     0     0     0     0 ];
    pV = [x1; x2; x3; x4; x5; x6];

    dxdu = (uV*cM)*pV
</pre><p>Note that the derivative of uV only needed to be computed to compute dxdu. This process is continued for all 5 derivatives of x(u) until the sixth and all following derivatives, which are 0. Higher derivatives w.r.t. to U are less expensive to compute than lower derivatives.</p>
<p><b>Computational Costs</b> </p>
<pre class="fragment">    dy/dx  : ~50 flops
    d2x/du2: ~43 flops
    d3x/du3: ~34 flops
    d4x/du4: ~26 flops
    d5x/du5: ~15 flops
    d6x/du6: ~1  flop
</pre><p><b>Example:</b> </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> u = 0.5;</div>
<div class="line"></div>
<div class="line"><span class="comment">//Choose the control points</span></div>
<div class="line">SimTK::Vector vX(6);</div>
<div class="line">vX(0) = -2;</div>
<div class="line">vX(1) = 0;</div>
<div class="line">vX(2) = 0;</div>
<div class="line">vX(3) = 4;</div>
<div class="line">vX(4) = 4;</div>
<div class="line">vX(5) = 6;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">double</span> dxdu  =<a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#a3b62b522472a4b6ee49f5ec53ebc16ab">calcQuinticBezierCurveDerivU</a>(u,vX,1);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa554df1eeb3b103e77a7a90f41895b35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenSim::SegmentedQuinticBezierToolkit::calcQuinticBezierCurveVal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vector &amp;&#160;</td>
          <td class="paramname"><em>pts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the value of a quintic Bezier curve at value u. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The independent variable of a Bezier curve, which ranges between 0.0 and 1.0. </td></tr>
    <tr><td class="paramname">pts</td><td>The locations of the control points in 1 dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classOpenSim_1_1Exception.html">OpenSim::Exception</a></td><td>-If u is outside of [0,1] -if pts has a length other than 6 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the Bezier curve located at u.</dd></dl>
<p>Calculates the value of a quintic Bezier curve at value u. This calculation is acheived by mulitplying a row vector comprised of powers of u, by the 6x6 coefficient matrix associated with a quintic Bezier curve, by the vector of Bezier control points, pV, in a particular dimension. The code to compute the value of a quintic bezier curve has been optimized to have the following cost:</p>
<p><b>Computational Costs</b> </p>
<pre class="fragment"> ~54 flops
</pre><p>The math this function executes is decribed in pseudo code as the following:</p>
<pre class="fragment">    uV = [u^5 u^4 u^3 u^2 u 1];

    cM = [ -1     5   -10    10    -5     1; 
            5   -20    30   -20     5     0; 
          -10    30   -30    10     0     0; 
           10   -20    10     0     0     0; 
           -5     5     0     0     0     0;
            1     0     0     0     0     0 ];
    pV = [x1; x2; x3; x4; x5; x6];

    xB = (uV*cM)*pV
</pre><p><b>Example:</b> </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> u = 0.5;</div>
<div class="line"></div>
<div class="line"><span class="comment">//Choose the control points</span></div>
<div class="line">SimTK::Vector vX(6);</div>
<div class="line">vX(0) = -2;</div>
<div class="line">vX(1) = 0;</div>
<div class="line">vX(2) = 0;</div>
<div class="line">vX(3) = 4;</div>
<div class="line">vX(4) = 4;</div>
<div class="line">vX(5) = 6;</div>
<div class="line"></div>
<div class="line">yVal = <a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#aa554df1eeb3b103e77a7a90f41895b35">SegmentedQuinticBezierToolkit::</a></div>
<div class="line"><a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#aa554df1eeb3b103e77a7a90f41895b35">         calcQuinticBezierCurveVal</a>(u,vX);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ad3a52714898f2e1e96eaf33ffcd0e80d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double OpenSim::SegmentedQuinticBezierToolkit::calcU </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vector &amp;&#160;</td>
          <td class="paramname"><em>bezierPtsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Spline &amp;&#160;</td>
          <td class="paramname"><em>splineUX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will compute the u value that correesponds to the given x for a quintic Bezier curve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ax</td><td>The x value </td></tr>
    <tr><td class="paramname">bezierPtsX</td><td>The 6 Bezier point values </td></tr>
    <tr><td class="paramname">splineUX</td><td>The spline for the approximate x(u) curve </td></tr>
    <tr><td class="paramname">tol</td><td>The desired tolerance on u. </td></tr>
    <tr><td class="paramname">maxIter</td><td>The maximum number of Newton iterations allowed</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classOpenSim_1_1Exception.html">OpenSim::Exception</a></td><td>-if ax is outside the range defined in this Bezier spline section -if the desired tolerance is not met -if the derivative goes to 0 to machine precision</td></tr>
  </table>
  </dd>
</dl>
<p>This function will compute the u value that correesponds to the given x for a quintic Bezier curve. This is accomplished by using an approximate spline inverse of u(x) to get a very good initial guess, and then one or two Newton iterations to polish the answer to the desired tolerance.</p>
<p><b>Computational Costs</b> </p>
<pre class="fragment">    ~219 flops
</pre><p><b>Example:</b> </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> xVal = 2;</div>
<div class="line"></div>
<div class="line"><span class="comment">//Choose the control points</span></div>
<div class="line">SimTK::Vector vX(6);</div>
<div class="line">vX(0) = -2;</div>
<div class="line">vX(1) = 0;</div>
<div class="line">vX(2) = 0;</div>
<div class="line">vX(3) = 4;</div>
<div class="line">vX(4) = 4;</div>
<div class="line">vX(5) = 6;</div>
<div class="line"></div>
<div class="line">SimTK::Vector x(100);</div>
<div class="line">SimTK::Vector u(100);</div>
<div class="line"></div>
<div class="line"><span class="comment">//Create the splined approximate inverse of u(x)</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;100; i++){</div>
<div class="line">    u(i) = ( (double)i )/( (double)(100-1) );</div>
<div class="line">    x(i) = <a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#aa554df1eeb3b103e77a7a90f41895b35">SegmentedQuinticBezierToolkit::</a></div>
<div class="line"><a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#aa554df1eeb3b103e77a7a90f41895b35">        calcQuinticBezierCurveVal</a>(u(i),vX); </div>
<div class="line">}</div>
<div class="line">SimTK::Spline splineUX = SimTK::SplineFitter&lt;Real&gt;::</div>
<div class="line">    fitForSmoothingParameter(3,x,u,0).getSpline();</div>
<div class="line"></div>
<div class="line"><span class="comment">//Now evalutate u at the given xVal</span></div>
<div class="line"><span class="keywordtype">double</span> u = <a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#ad3a52714898f2e1e96eaf33ffcd0e80d">SegmentedQuinticBezierToolkit::</a></div>
<div class="line"><a class="code" href="classOpenSim_1_1SegmentedQuinticBezierToolkit.html#ad3a52714898f2e1e96eaf33ffcd0e80d">         calcU</a>(xVal,vX, splineUX, 1e-12,20);</div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/ReleaseEnv/src/OpenSim32Branch/OpenSim/Common/SegmentedQuinticBezierToolkit.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
</body>
</html>
